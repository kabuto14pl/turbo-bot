"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.allMetrics = exports.healthMetrics = exports.orderMetrics = exports.marketMetrics = exports.riskMetrics = exports.strategyMetrics = exports.systemMetrics = exports.tradingMetrics = void 0;
exports.updatePortfolioMetrics = updatePortfolioMetrics;
exports.recordTrade = recordTrade;
exports.recordSignal = recordSignal;
exports.updateMarketData = updateMarketData;
exports.recordOrderExecution = recordOrderExecution;
exports.updateComponentHealth = updateComponentHealth;
exports.recordLogEvent = recordLogEvent;
exports.updateRiskMetrics = updateRiskMetrics;
exports.updateSystemPerformance = updateSystemPerformance;
exports.recordTradingCycle = recordTradingCycle;
exports.triggerAlert = triggerAlert;
exports.getMetrics = getMetrics;
exports.getRegistry = getRegistry;
/**
 * ðŸš€ [PRODUCTION-OPERATIONAL]
 * Production monitoring component
 */
/**
 * ðŸ”§ [SHARED-INFRASTRUCTURE]
 * Shared trading bot infrastructure
 */
const promClient = __importStar(require("prom-client"));
/**
 * ðŸš€ PROMETHEUS METRICS EXPORTER FOR TRADING BOT
 *
 * Eksportuje metryki dla Grafana Dashboard
 */
// Clear default metrics
promClient.register.clear();
// Enable collection of default metrics
promClient.collectDefaultMetrics({
    gcDurationBuckets: [0.001, 0.01, 0.1, 1, 2, 5]
});
// =============================================================================
// ðŸ“Š TRADING PERFORMANCE METRICS
// =============================================================================
exports.tradingMetrics = {
    // Portfolio metrics
    portfolioValue: new promClient.Gauge({
        name: 'trading_bot_portfolio_value',
        help: 'Current portfolio value in USD',
    }),
    totalPnL: new promClient.Gauge({
        name: 'trading_bot_total_pnl',
        help: 'Total profit and loss in USD',
    }),
    // Trading activity
    totalTrades: new promClient.Counter({
        name: 'trading_bot_total_trades',
        help: 'Total number of trades executed',
        labelNames: ['symbol', 'side']
    }),
    profitableTrades: new promClient.Counter({
        name: 'trading_bot_profitable_trades',
        help: 'Number of profitable trades',
        labelNames: ['symbol', 'strategy']
    }),
    winRate: new promClient.Gauge({
        name: 'trading_bot_win_rate',
        help: 'Win rate percentage (0-1)',
    }),
    // Signal generation
    signalsGenerated: new promClient.Counter({
        name: 'trading_bot_signals_generated',
        help: 'Total signals generated',
        labelNames: ['strategy', 'signal_type']
    }),
    signalsByStrategy: new promClient.Gauge({
        name: 'trading_bot_signals_by_strategy',
        help: 'Signals generated by each strategy',
        labelNames: ['strategy']
    }),
};
// =============================================================================
// âš¡ SYSTEM PERFORMANCE METRICS
// =============================================================================
exports.systemMetrics = {
    // Latency metrics
    marketDataLatency: new promClient.Histogram({
        name: 'trading_bot_market_data_latency',
        help: 'Market data processing latency in milliseconds',
        buckets: [1, 5, 10, 25, 50, 100, 250, 500, 1000]
    }),
    tradingCycleDuration: new promClient.Histogram({
        name: 'trading_bot_trading_cycle_duration',
        help: 'Trading cycle duration in milliseconds',
        buckets: [10, 50, 100, 250, 500, 1000, 2500, 5000]
    }),
    orderExecutionTime: new promClient.Histogram({
        name: 'trading_bot_order_execution_time',
        help: 'Order execution time in milliseconds',
        buckets: [50, 100, 250, 500, 1000, 2500, 5000]
    }),
    // Connection metrics
    activePairs: new promClient.Gauge({
        name: 'trading_bot_active_pairs',
        help: 'Number of active trading pairs',
    }),
    websocketConnections: new promClient.Gauge({
        name: 'trading_bot_websocket_connections',
        help: 'Number of active websocket connections',
    }),
    kafkaMessagesRate: new promClient.Gauge({
        name: 'trading_bot_kafka_messages_rate',
        help: 'Kafka messages per second',
    }),
};
// =============================================================================
// ðŸŽ¯ STRATEGY METRICS
// =============================================================================
exports.strategyMetrics = {
    strategyPerformanceAccuracy: new promClient.Gauge({
        name: 'trading_bot_strategy_performance_accuracy',
        help: 'Strategy performance accuracy percentage',
        labelNames: ['strategy']
    }),
    strategyDrawdown: new promClient.Gauge({
        name: 'trading_bot_strategy_drawdown',
        help: 'Strategy maximum drawdown',
        labelNames: ['strategy']
    }),
};
// =============================================================================
// âš ï¸ RISK MANAGEMENT METRICS
// =============================================================================
exports.riskMetrics = {
    maxDrawdown: new promClient.Gauge({
        name: 'trading_bot_max_drawdown',
        help: 'Maximum portfolio drawdown percentage',
    }),
    sharpeRatio: new promClient.Gauge({
        name: 'trading_bot_sharpe_ratio',
        help: 'Portfolio Sharpe ratio',
    }),
    portfolioExposure: new promClient.Gauge({
        name: 'trading_bot_portfolio_exposure',
        help: 'Current portfolio exposure percentage',
    }),
    riskUtilization: new promClient.Gauge({
        name: 'trading_bot_risk_utilization',
        help: 'Risk utilization percentage',
    }),
};
// =============================================================================
// ðŸ’± MARKET DATA METRICS
// =============================================================================
exports.marketMetrics = {
    marketPrice: new promClient.Gauge({
        name: 'trading_bot_market_price',
        help: 'Current market price for trading pairs',
        labelNames: ['symbol']
    }),
    marketVolume: new promClient.Gauge({
        name: 'trading_bot_market_volume',
        help: 'Current market volume for trading pairs',
        labelNames: ['symbol']
    }),
    priceChange: new promClient.Gauge({
        name: 'trading_bot_price_change',
        help: 'Price change percentage for trading pairs',
        labelNames: ['symbol']
    }),
};
// =============================================================================
// ðŸ“‹ ORDER EXECUTION METRICS
// =============================================================================
exports.orderMetrics = {
    ordersExecuted: new promClient.Counter({
        name: 'trading_bot_orders_executed',
        help: 'Total orders executed',
        labelNames: ['symbol', 'side', 'type']
    }),
    ordersFailed: new promClient.Counter({
        name: 'trading_bot_orders_failed',
        help: 'Total orders failed',
        labelNames: ['symbol', 'side', 'error_type']
    }),
    orderFillRate: new promClient.Gauge({
        name: 'trading_bot_order_fill_rate',
        help: 'Order fill rate percentage',
    }),
};
// =============================================================================
// ðŸš¨ HEALTH & ALERTS METRICS
// =============================================================================
exports.healthMetrics = {
    componentHealth: new promClient.Gauge({
        name: 'trading_bot_component_health',
        help: 'Component health status (1=healthy, 0=unhealthy)',
        labelNames: ['component']
    }),
    alertsTriggered: new promClient.Counter({
        name: 'trading_bot_alert_triggered',
        help: 'Number of alerts triggered',
        labelNames: ['alert_type', 'severity']
    }),
    logEvents: new promClient.Counter({
        name: 'trading_bot_log_events_total',
        help: 'Total log events by level',
        labelNames: ['level']
    }),
};
// =============================================================================
// ðŸ“ˆ UTILITY FUNCTIONS
// =============================================================================
/**
 * Update portfolio metrics
 */
function updatePortfolioMetrics(portfolioValue, totalPnL, winRate) {
    exports.tradingMetrics.portfolioValue.set(portfolioValue);
    exports.tradingMetrics.totalPnL.set(totalPnL);
    exports.tradingMetrics.winRate.set(winRate);
}
/**
 * Record a trade
 */
function recordTrade(symbol, side, profitable, strategy) {
    exports.tradingMetrics.totalTrades.inc({ symbol, side });
    if (profitable) {
        exports.tradingMetrics.profitableTrades.inc({ symbol, strategy });
    }
}
/**
 * Record a signal
 */
function recordSignal(strategy, signalType) {
    exports.tradingMetrics.signalsGenerated.inc({ strategy, signal_type: signalType });
    exports.tradingMetrics.signalsByStrategy.inc({ strategy });
}
/**
 * Update market data
 */
function updateMarketData(symbol, price, volume, priceChangePercent, latency) {
    exports.marketMetrics.marketPrice.set({ symbol }, price);
    exports.marketMetrics.marketVolume.set({ symbol }, volume);
    exports.marketMetrics.priceChange.set({ symbol }, priceChangePercent);
    exports.systemMetrics.marketDataLatency.observe(latency);
}
/**
 * Record order execution
 */
function recordOrderExecution(symbol, side, type, executionTime, success) {
    if (success) {
        exports.orderMetrics.ordersExecuted.inc({ symbol, side, type });
    }
    else {
        exports.orderMetrics.ordersFailed.inc({ symbol, side, error_type: 'execution_failed' });
    }
    exports.systemMetrics.orderExecutionTime.observe(executionTime);
}
/**
 * Update system health
 */
function updateComponentHealth(component, healthy) {
    exports.healthMetrics.componentHealth.set({ component }, healthy ? 1 : 0);
}
/**
 * Record log event
 */
function recordLogEvent(level) {
    exports.healthMetrics.logEvents.inc({ level });
}
/**
 * Update risk metrics
 */
function updateRiskMetrics(maxDrawdown, sharpeRatio, exposure, riskUtil) {
    exports.riskMetrics.maxDrawdown.set(maxDrawdown);
    exports.riskMetrics.sharpeRatio.set(sharpeRatio);
    exports.riskMetrics.portfolioExposure.set(exposure);
    exports.riskMetrics.riskUtilization.set(riskUtil);
}
/**
 * Update system performance
 */
function updateSystemPerformance(activePairs, wsConnections, kafkaRate) {
    exports.systemMetrics.activePairs.set(activePairs);
    exports.systemMetrics.websocketConnections.set(wsConnections);
    exports.systemMetrics.kafkaMessagesRate.set(kafkaRate);
}
/**
 * Record trading cycle
 */
function recordTradingCycle(duration) {
    exports.systemMetrics.tradingCycleDuration.observe(duration);
}
/**
 * Trigger alert
 */
function triggerAlert(alertType, severity) {
    exports.healthMetrics.alertsTriggered.inc({ alert_type: alertType, severity });
}
/**
 * Get metrics for Prometheus endpoint
 */
async function getMetrics() {
    return await promClient.register.metrics();
}
/**
 * Get metrics registry
 */
function getRegistry() {
    return promClient.register;
}
// Export all metric groups
exports.allMetrics = {
    trading: exports.tradingMetrics,
    system: exports.systemMetrics,
    strategy: exports.strategyMetrics,
    risk: exports.riskMetrics,
    market: exports.marketMetrics,
    orders: exports.orderMetrics,
    health: exports.healthMetrics,
};
// Initialize component health checks
const components = [
    'enterprise_data_pipeline',
    'binance_websocket',
    'kafka_streaming',
    'risk_manager',
    'portfolio_manager',
    'strategy_engine',
    'order_executor',
    'alert_system'
];
components.forEach(component => {
    updateComponentHealth(component, true);
});
console.log('ðŸš€ Prometheus metrics initialized for Trading Bot Dashboard');
