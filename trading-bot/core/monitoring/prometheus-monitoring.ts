/**
 * üöÄ [PRODUCTION-OPERATIONAL]
 * Production monitoring component
 */
/**
 * üîß [SHARED-INFRASTRUCTURE]
 * Shared trading bot infrastructure
 */
import { register, Registry, Counter, Gauge, Histogram, collectDefaultMetrics } from 'prom-client';
import express from 'express';
import { EventEmitter } from 'events';

/**
 * Trading strategy metrics interface
 */
export interface StrategyMetrics {
    strategyName: string;
    signalsGenerated: number;
    signalsExecuted: number;
    profitLoss: number;
    sharpeRatio: number;
    maxDrawdown: number;
    winRate: number;
    avgTradeTime: number;
    totalTrades: number;
}

/**
 * System health metrics interface
 */
export interface SystemHealthMetrics {
    cpuUsage: number;
    memoryUsage: number;
    diskUsage: number;
    networkLatency: number;
    errorRate: number;
    uptime: number;
}

/**
 * Production-grade monitoring system using Prometheus
 * Addresses critical gap: Distributed monitoring
 * 
 * Provides:
 * - Real-time performance metrics
 * - System health monitoring
 * - Trading strategy analytics
 * - Alerting capabilities
 * - Grafana dashboard integration
 */
export class PrometheusMonitoring extends EventEmitter {
    private registry: Registry;
    private app: express.Application;
    private server: any = null;
    private port: number = 9090;
    
    // Strategy Performance Metrics
    private strategySignalsTotal!: Counter<string>;
    private strategyExecutionsTotal!: Counter<string>;
    private strategyProfitLoss!: Gauge<string>;
    private strategySharpeRatio!: Gauge<string>;
    private strategyMaxDrawdown!: Gauge<string>;
    private strategyWinRate!: Gauge<string>;
    private tradeExecutionTime!: Histogram<string>;
    
    // System Health Metrics
    private systemCpuUsage!: Gauge<string>;
    private systemMemoryUsage!: Gauge<string>;
    private systemDiskUsage!: Gauge<string>;
    private networkLatency!: Histogram<string>;
    private errorRate!: Counter<string>;
    private systemUptime!: Gauge<string>;
    
    // Risk Management Metrics
    private portfolioValue!: Gauge<string>;
    private portfolioExposure!: Gauge<string>;
    private riskScore!: Gauge<string>;
    private positionSize!: Gauge<string>;
    private correlationRisk!: Gauge<string>;
    
    // Market Data Metrics
    private marketDataLatency!: Histogram<string>;
    private marketDataDrops!: Counter<string>;
    private websocketConnections!: Gauge<string>;
    
    // Alert Metrics
    private alertsTotal!: Counter<string>;
    private criticalAlertsTotal!: Counter<string>;
    
    // Trading Bot Specific Metrics (for Grafana dashboard)
    private tradingBotStatus!: Gauge<string>;
    private tradingBotPortfolioValue!: Gauge<string>;
    private tradingBotTradesTotal!: Counter<string>;
    private tradingBotUptime!: Gauge<string>;
    private tradingBotCpuUsage!: Gauge<string>;
    private tradingBotMemoryUsage!: Gauge<string>;

    constructor(port?: number) {
        super();
        
        this.port = port || 9090;
        this.registry = new Registry();
        this.app = express();
        
        // Initialize all metrics
        this.initializeMetrics();
        
        // Setup express app
        this.setupExpressApp();
        
        // Collect default Node.js metrics
        collectDefaultMetrics({ register: this.registry });
        
        console.log('üìä Prometheus monitoring initialized');
    }

    /**
     * Initialize all Prometheus metrics
     */
    private initializeMetrics(): void {
        // Strategy Performance Metrics
        this.strategySignalsTotal = new Counter({
            name: 'trading_strategy_signals_total',
            help: 'Total number of trading signals generated by strategy',
            labelNames: ['strategy', 'signal_type', 'symbol'],
            registers: [this.registry]
        });

        this.strategyExecutionsTotal = new Counter({
            name: 'trading_strategy_executions_total',
            help: 'Total number of trades executed by strategy',
            labelNames: ['strategy', 'side', 'symbol', 'status'],
            registers: [this.registry]
        });

        this.strategyProfitLoss = new Gauge({
            name: 'trading_strategy_profit_loss',
            help: 'Current profit/loss for each strategy',
            labelNames: ['strategy', 'symbol'],
            registers: [this.registry]
        });

        this.strategySharpeRatio = new Gauge({
            name: 'trading_strategy_sharpe_ratio',
            help: 'Sharpe ratio for each strategy',
            labelNames: ['strategy'],
            registers: [this.registry]
        });

        this.strategyMaxDrawdown = new Gauge({
            name: 'trading_strategy_max_drawdown',
            help: 'Maximum drawdown for each strategy',
            labelNames: ['strategy'],
            registers: [this.registry]
        });

        this.strategyWinRate = new Gauge({
            name: 'trading_strategy_win_rate',
            help: 'Win rate percentage for each strategy',
            labelNames: ['strategy'],
            registers: [this.registry]
        });

        this.tradeExecutionTime = new Histogram({
            name: 'trading_execution_time_seconds',
            help: 'Time taken to execute trades',
            labelNames: ['strategy', 'symbol'],
            buckets: [0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1.0, 5.0],
            registers: [this.registry]
        });

        // System Health Metrics
        this.systemCpuUsage = new Gauge({
            name: 'system_cpu_usage_percent',
            help: 'Current CPU usage percentage',
            labelNames: ['component'],
            registers: [this.registry]
        });

        this.systemMemoryUsage = new Gauge({
            name: 'system_memory_usage_bytes',
            help: 'Current memory usage in bytes',
            labelNames: ['type'],
            registers: [this.registry]
        });

        this.systemDiskUsage = new Gauge({
            name: 'system_disk_usage_percent',
            help: 'Current disk usage percentage',
            labelNames: ['mount_point'],
            registers: [this.registry]
        });

        this.networkLatency = new Histogram({
            name: 'network_latency_seconds',
            help: 'Network latency to external services',
            labelNames: ['service', 'endpoint'],
            buckets: [0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1.0],
            registers: [this.registry]
        });

        this.errorRate = new Counter({
            name: 'system_errors_total',
            help: 'Total number of system errors',
            labelNames: ['component', 'error_type', 'severity'],
            registers: [this.registry]
        });

        this.systemUptime = new Gauge({
            name: 'system_uptime_seconds',
            help: 'System uptime in seconds',
            registers: [this.registry]
        });

        // Risk Management Metrics
        this.portfolioValue = new Gauge({
            name: 'portfolio_value_usd',
            help: 'Current portfolio value in USD',
            labelNames: ['account'],
            registers: [this.registry]
        });

        this.portfolioExposure = new Gauge({
            name: 'portfolio_exposure_percent',
            help: 'Current portfolio exposure percentage',
            labelNames: ['asset_class', 'symbol'],
            registers: [this.registry]
        });

        this.riskScore = new Gauge({
            name: 'risk_score',
            help: 'Current risk score (0-100)',
            labelNames: ['type'],
            registers: [this.registry]
        });

        this.positionSize = new Gauge({
            name: 'position_size_usd',
            help: 'Current position size in USD',
            labelNames: ['symbol', 'side'],
            registers: [this.registry]
        });

        this.correlationRisk = new Gauge({
            name: 'correlation_risk_score',
            help: 'Portfolio correlation risk score',
            labelNames: ['portfolio'],
            registers: [this.registry]
        });

        // Market Data Metrics
        this.marketDataLatency = new Histogram({
            name: 'market_data_latency_seconds',
            help: 'Latency of market data updates',
            labelNames: ['exchange', 'symbol', 'feed_type'],
            buckets: [0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1.0],
            registers: [this.registry]
        });

        this.marketDataDrops = new Counter({
            name: 'market_data_drops_total',
            help: 'Total number of dropped market data messages',
            labelNames: ['exchange', 'symbol', 'reason'],
            registers: [this.registry]
        });

        this.websocketConnections = new Gauge({
            name: 'websocket_connections_active',
            help: 'Number of active WebSocket connections',
            labelNames: ['exchange', 'feed_type'],
            registers: [this.registry]
        });

        // Alert Metrics
        this.alertsTotal = new Counter({
            name: 'alerts_total',
            help: 'Total number of alerts generated',
            labelNames: ['type', 'severity', 'component'],
            registers: [this.registry]
        });

        this.criticalAlertsTotal = new Counter({
            name: 'critical_alerts_total',
            help: 'Total number of critical alerts',
            labelNames: ['component', 'alert_type'],
            registers: [this.registry]
        });

        // Trading Bot Specific Metrics for Grafana Dashboard
        this.tradingBotStatus = new Gauge({
            name: 'trading_bot_status',
            help: 'Trading bot status (1 = running, 0 = stopped)',
            registers: [this.registry]
        });

        this.tradingBotPortfolioValue = new Gauge({
            name: 'trading_bot_portfolio_value',
            help: 'Current portfolio value in USD',
            registers: [this.registry]
        });

        this.tradingBotTradesTotal = new Counter({
            name: 'trading_bot_trades_total',
            help: 'Total number of trades executed by the bot',
            registers: [this.registry]
        });

        this.tradingBotUptime = new Gauge({
            name: 'trading_bot_uptime',
            help: 'Trading bot uptime in seconds',
            registers: [this.registry]
        });

        this.tradingBotCpuUsage = new Gauge({
            name: 'trading_bot_cpu_usage',
            help: 'Trading bot CPU usage percentage',
            registers: [this.registry]
        });

        this.tradingBotMemoryUsage = new Gauge({
            name: 'trading_bot_memory_usage',
            help: 'Trading bot memory usage in MB',
            registers: [this.registry]
        });

        // Set initial values
        this.tradingBotStatus.set(1); // 1 = running, 0 = stopped
        this.tradingBotPortfolioValue.set(10000); // Initial portfolio value
        this.tradingBotUptime.set(0); // Will be updated dynamically
        this.tradingBotCpuUsage.set(0); // Will be updated dynamically
        this.tradingBotMemoryUsage.set(0); // Will be updated dynamically
    }

    /**
     * Setup Express app for metrics endpoint
     */
    private setupExpressApp(): void {
        // Health check endpoint
        this.app.get('/health', (req, res) => {
            res.json({
                status: 'healthy',
                timestamp: Date.now(),
                uptime: process.uptime()
            });
        });

        // Metrics endpoint for Prometheus scraping
        this.app.get('/metrics', async (req, res) => {
            try {
                res.set('Content-Type', this.registry.contentType);
                const metrics = await this.registry.metrics();
                res.end(metrics);
            } catch (error) {
                console.error('‚ùå Error generating metrics:', error);
                res.status(500).end('Error generating metrics');
            }
        });

        // Custom metrics endpoint for debugging
        this.app.get('/metrics/custom', async (req, res) => {
            try {
                const customMetrics = {
                    strategyMetrics: await this.getStrategyMetrics(),
                    systemHealth: await this.getSystemHealth(),
                    riskMetrics: await this.getRiskMetrics()
                };
                res.json(customMetrics);
            } catch (error) {
                console.error('‚ùå Error generating custom metrics:', error);
                res.status(500).json({ error: 'Error generating custom metrics' });
            }
        });

        // AlertManager webhook endpoints
        this.app.post('/webhook/alerts', express.json(), (req, res) => {
            try {
                console.log('üì® Received AlertManager webhook:', req.body);
                this.handleAlertManagerWebhook(req.body);
                res.status(200).json({ status: 'received' });
            } catch (error) {
                console.error('‚ùå Error handling AlertManager webhook:', error);
                res.status(500).json({ error: 'Error processing webhook' });
            }
        });

        this.app.post('/webhook/alerts/critical', express.json(), (req, res) => {
            try {
                console.log('üö® CRITICAL AlertManager webhook:', req.body);
                this.handleAlertManagerWebhook(req.body, 'critical');
                res.status(200).json({ status: 'received' });
            } catch (error) {
                console.error('‚ùå Error handling critical webhook:', error);
                res.status(500).json({ error: 'Error processing webhook' });
            }
        });

        this.app.post('/webhook/alerts/emergency', express.json(), (req, res) => {
            try {
                console.log('üÜò EMERGENCY AlertManager webhook:', req.body);
                this.handleAlertManagerWebhook(req.body, 'emergency');
                res.status(200).json({ status: 'received' });
            } catch (error) {
                console.error('‚ùå Error handling emergency webhook:', error);
                res.status(500).json({ error: 'Error processing webhook' });
            }
        });

        this.app.post('/webhook/alerts/risk', express.json(), (req, res) => {
            try {
                console.log('‚ö†Ô∏è RISK AlertManager webhook:', req.body);
                this.handleAlertManagerWebhook(req.body, 'risk');
                res.status(200).json({ status: 'received' });
            } catch (error) {
                console.error('‚ùå Error handling risk webhook:', error);
                res.status(500).json({ error: 'Error processing webhook' });
            }
        });

        // üß™ TEST TRADE ENDPOINT - Generate simulated trade for testing
        this.app.post('/test/trade', express.json(), (req, res) => {
            try {
                console.log('üß™ TEST TRADE requested');
                
                // Generate test trade
                const testTrade = {
                    symbol: req.body.symbol || 'BTCUSDT',
                    side: req.body.side || 'buy',
                    amount: req.body.amount || 0.001,
                    price: req.body.price || 45000,
                    timestamp: Date.now()
                };

                // Update trades counter
                this.strategyExecutionsTotal.inc({
                    strategy: 'test_strategy',
                    side: testTrade.side,
                    symbol: testTrade.symbol,
                    status: 'executed'
                });

                // Update portfolio value (simulate profit)
                const portfolioChange = testTrade.side === 'buy' ? testTrade.amount * testTrade.price : -testTrade.amount * testTrade.price;
                
                console.log(`üß™ TEST TRADE executed: ${testTrade.side} ${testTrade.amount} ${testTrade.symbol} @ $${testTrade.price}`);
                
                res.status(200).json({ 
                    status: 'executed',
                    trade: testTrade,
                    message: 'Test trade simulated successfully'
                });
            } catch (error) {
                console.error('‚ùå Error executing test trade:', error);
                res.status(500).json({ error: 'Error executing test trade' });
            }
        });
    }

    /**
     * Start the monitoring server
     */
    async start(): Promise<void> {
        return new Promise((resolve, reject) => {
            try {
                this.server = this.app.listen(this.port, '0.0.0.0', () => {
                    console.log(`üìä Prometheus monitoring server started on port ${this.port}`);
                    console.log(`üìà Metrics endpoint: http://localhost:${this.port}/metrics`);
                    console.log(`üè• Health endpoint: http://localhost:${this.port}/health`);
                    
                    // Start collecting system metrics
                    this.startSystemMetricsCollection();
                    
                    this.emit('started');
                    resolve();
                });

                this.server.on('error', (error: Error) => {
                    console.error('‚ùå Monitoring server error:', error);
                    reject(error);
                });

            } catch (error) {
                reject(error);
            }
        });
    }

    /**
     * Stop the monitoring server
     */
    async stop(): Promise<void> {
        return new Promise((resolve) => {
            if (this.server) {
                this.server.close(() => {
                    console.log('üìä Prometheus monitoring server stopped');
                    this.emit('stopped');
                    resolve();
                });
            } else {
                resolve();
            }
        });
    }

    /**
     * Record strategy signal generation
     */
    recordStrategySignal(strategy: string, signalType: string, symbol: string): void {
        this.strategySignalsTotal.inc({ strategy, signal_type: signalType, symbol });
    }

    /**
     * Record strategy execution
     */
    recordStrategyExecution(strategy: string, side: string, symbol: string, status: string, executionTime: number): void {
        this.strategyExecutionsTotal.inc({ strategy, side, symbol, status });
        this.tradeExecutionTime.observe({ strategy, symbol }, executionTime);
    }

    /**
     * Update strategy performance metrics
     */
    updateStrategyMetrics(metrics: StrategyMetrics): void {
        const { strategyName } = metrics;
        
        this.strategyProfitLoss.set({ strategy: strategyName, symbol: 'ALL' }, metrics.profitLoss);
        this.strategySharpeRatio.set({ strategy: strategyName }, metrics.sharpeRatio);
        this.strategyMaxDrawdown.set({ strategy: strategyName }, metrics.maxDrawdown);
        this.strategyWinRate.set({ strategy: strategyName }, metrics.winRate);
    }

    /**
     * Update system health metrics
     */
    updateSystemHealth(metrics: SystemHealthMetrics): void {
        this.systemCpuUsage.set({ component: 'trading-bot' }, metrics.cpuUsage);
        this.systemMemoryUsage.set({ type: 'used' }, metrics.memoryUsage);
        this.systemUptime.set(metrics.uptime);
    }

    /**
     * Record system error
     */
    recordError(component: string, errorType: string, severity: string): void {
        this.errorRate.inc({ component, error_type: errorType, severity });
    }

    /**
     * Update portfolio metrics
     */
    updatePortfolioMetrics(value: number, exposure: { [key: string]: number }, riskScore: number): void {
        this.portfolioValue.set({ account: 'main' }, value);
        this.riskScore.set({ type: 'overall' }, riskScore);
        
        Object.entries(exposure).forEach(([symbol, exposureValue]) => {
            this.portfolioExposure.set({ asset_class: 'crypto', symbol }, exposureValue);
        });
    }

    /**
     * Record market data latency
     */
    recordMarketDataLatency(exchange: string, symbol: string, feedType: string, latency: number): void {
        this.marketDataLatency.observe({ exchange, symbol, feed_type: feedType }, latency);
    }

    /**
     * Record market data drop
     */
    recordMarketDataDrop(exchange: string, symbol: string, reason: string): void {
        this.marketDataDrops.inc({ exchange, symbol, reason });
    }

    /**
     * Update WebSocket connection count
     */
    updateWebSocketConnections(exchange: string, feedType: string, count: number): void {
        this.websocketConnections.set({ exchange, feed_type: feedType }, count);
    }

    /**
     * Record alert
     */
    recordAlert(type: string, severity: string, component: string): void {
        this.alertsTotal.inc({ type, severity, component });
        
        if (severity === 'critical') {
            this.criticalAlertsTotal.inc({ component, alert_type: type });
        }
    }

    /**
     * Start automatic system metrics collection
     */
    private startSystemMetricsCollection(): void {
        setInterval(() => {
            // Collect system metrics
            const memUsage = process.memoryUsage();
            const cpuUsage = process.cpuUsage();
            
            this.systemMemoryUsage.set({ type: 'heap_used' }, memUsage.heapUsed);
            this.systemMemoryUsage.set({ type: 'heap_total' }, memUsage.heapTotal);
            this.systemMemoryUsage.set({ type: 'external' }, memUsage.external);
            this.systemMemoryUsage.set({ type: 'rss' }, memUsage.rss);
            
            this.systemUptime.set(process.uptime());
            
        }, 5000); // Collect every 5 seconds
    }

    /**
     * Get current strategy metrics summary
     */
    private async getStrategyMetrics(): Promise<any> {
        // This would be populated with actual strategy data
        return {
            totalSignals: 0, // Would be calculated from counters
            totalExecutions: 0,
            avgProfitLoss: 0,
            avgSharpeRatio: 0
        };
    }

    /**
     * Get current system health summary
     */
    private async getSystemHealth(): Promise<any> {
        const memUsage = process.memoryUsage();
        return {
            uptime: process.uptime(),
            memory: {
                heapUsed: memUsage.heapUsed,
                heapTotal: memUsage.heapTotal,
                external: memUsage.external,
                rss: memUsage.rss
            },
            loadAverage: require('os').loadavg()
        };
    }

    /**
     * Get current risk metrics summary
     */
    private async getRiskMetrics(): Promise<any> {
        return {
            portfolioValue: 0, // Would be actual portfolio value
            riskScore: 0,
            maxExposure: 0
        };
    }

    /**
     * Get monitoring status
     */
    getStatus(): {
        running: boolean;
        port: number;
        metricsEndpoint: string;
        healthEndpoint: string;
    } {
        return {
            running: this.server !== null,
            port: this.port,
            metricsEndpoint: `http://localhost:${this.port}/metrics`,
            healthEndpoint: `http://localhost:${this.port}/health`
        };
    }

    /**
     * Handle AlertManager webhook notifications
     */
    private handleAlertManagerWebhook(alertData: any, alertType?: string): void {
        try {
            const alerts = alertData.alerts || [];
            console.log(`üìä Processing ${alerts.length} alerts from AlertManager (type: ${alertType || 'general'})`);

            for (const alert of alerts) {
                this.processPrometheusAlert(alert, alertType);
            }

            // Emit event for other systems to handle
            this.emit('alertmanager_webhook', { alertData, alertType });

        } catch (error) {
            console.error('‚ùå Error processing AlertManager webhook:', error);
        }
    }

    /**
     * Process individual Prometheus alert
     */
    private processPrometheusAlert(alert: any, alertType?: string): void {
        const alertInfo = {
            name: alert.labels?.alertname,
            severity: alert.labels?.severity,
            category: alert.labels?.category,
            status: alert.status,
            description: alert.annotations?.description,
            summary: alert.annotations?.summary,
            startsAt: alert.startsAt,
            endsAt: alert.endsAt,
            labels: alert.labels,
            type: alertType
        };

        console.log(`üîî Alert: ${alertInfo.name} (${alertInfo.severity}) - ${alertInfo.description}`);

        // Record alert metric
        this.recordAlert(
            alertInfo.name || 'unknown',
            alertInfo.severity || 'unknown',
            alertInfo.category || 'system'
        );

        // Emit specific alert events
        this.emit('prometheus_alert', alertInfo);
        
        if (alertType === 'critical' || alertInfo.severity === 'critical') {
            this.emit('critical_alert', alertInfo);
        }
        
        if (alertType === 'emergency' || alertInfo.severity === 'emergency') {
            this.emit('emergency_alert', alertInfo);
        }
    }

    /**
     * Get custom metrics for external systems
     */
    async getCustomMetrics(): Promise<{
        strategyMetrics: any;
        systemHealth: any;
        riskMetrics: any;
    }> {
        return {
            strategyMetrics: await this.getStrategyMetrics(),
            systemHealth: await this.getSystemHealth(),
            riskMetrics: await this.getRiskMetrics()
        };
    }

    /**
     * Update trading bot status
     */
    updateTradingBotStatus(status: number): void {
        this.tradingBotStatus.set(status); // 1 = running, 0 = stopped
    }

    /**
     * Update trading bot portfolio value
     */
    updateTradingBotPortfolioValue(value: number): void {
        this.tradingBotPortfolioValue.set(value);
    }

    /**
     * Record trading bot trade
     */
    recordTradingBotTrade(): void {
        this.tradingBotTradesTotal.inc();
    }

    /**
     * Update trading bot uptime
     */
    updateTradingBotUptime(uptime: number): void {
        this.tradingBotUptime.set(uptime);
    }

    /**
     * Update trading bot system metrics
     */
    updateTradingBotSystemMetrics(cpuUsage: number, memoryUsage: number): void {
        this.tradingBotCpuUsage.set(cpuUsage);
        this.tradingBotMemoryUsage.set(memoryUsage);
    }
}

// Export default instance
export default new PrometheusMonitoring();
