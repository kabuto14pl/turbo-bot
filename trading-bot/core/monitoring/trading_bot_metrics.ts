/**
 * üöÄ [PRODUCTION-OPERATIONAL]
 * Production monitoring component
 */
/**
 * üîß [SHARED-INFRASTRUCTURE]
 * Shared trading bot infrastructure
 */
import * as promClient from 'prom-client';

/**
 * üöÄ PROMETHEUS METRICS EXPORTER FOR TRADING BOT
 * 
 * Eksportuje metryki dla Grafana Dashboard
 */

// Clear default metrics
promClient.register.clear();

// Enable collection of default metrics
promClient.collectDefaultMetrics({ 
  gcDurationBuckets: [0.001, 0.01, 0.1, 1, 2, 5]
});

// =============================================================================
// üìä TRADING PERFORMANCE METRICS
// =============================================================================

export const tradingMetrics = {
  // Portfolio metrics
  portfolioValue: new promClient.Gauge({
    name: 'trading_bot_portfolio_value',
    help: 'Current portfolio value in USD',
  }),

  totalPnL: new promClient.Gauge({
    name: 'trading_bot_total_pnl',
    help: 'Total profit and loss in USD',
  }),

  // Trading activity
  totalTrades: new promClient.Counter({
    name: 'trading_bot_total_trades',
    help: 'Total number of trades executed',
    labelNames: ['symbol', 'side']
  }),

  profitableTrades: new promClient.Counter({
    name: 'trading_bot_profitable_trades',
    help: 'Number of profitable trades',
    labelNames: ['symbol', 'strategy']
  }),

  winRate: new promClient.Gauge({
    name: 'trading_bot_win_rate',
    help: 'Win rate percentage (0-1)',
  }),

  // Signal generation
  signalsGenerated: new promClient.Counter({
    name: 'trading_bot_signals_generated',
    help: 'Total signals generated',
    labelNames: ['strategy', 'signal_type']
  }),

  signalsByStrategy: new promClient.Gauge({
    name: 'trading_bot_signals_by_strategy',
    help: 'Signals generated by each strategy',
    labelNames: ['strategy']
  }),
};

// =============================================================================
// ‚ö° SYSTEM PERFORMANCE METRICS
// =============================================================================

export const systemMetrics = {
  // Latency metrics
  marketDataLatency: new promClient.Histogram({
    name: 'trading_bot_market_data_latency',
    help: 'Market data processing latency in milliseconds',
    buckets: [1, 5, 10, 25, 50, 100, 250, 500, 1000]
  }),

  tradingCycleDuration: new promClient.Histogram({
    name: 'trading_bot_trading_cycle_duration',
    help: 'Trading cycle duration in milliseconds',
    buckets: [10, 50, 100, 250, 500, 1000, 2500, 5000]
  }),

  orderExecutionTime: new promClient.Histogram({
    name: 'trading_bot_order_execution_time',
    help: 'Order execution time in milliseconds',
    buckets: [50, 100, 250, 500, 1000, 2500, 5000]
  }),

  // Connection metrics
  activePairs: new promClient.Gauge({
    name: 'trading_bot_active_pairs',
    help: 'Number of active trading pairs',
  }),

  websocketConnections: new promClient.Gauge({
    name: 'trading_bot_websocket_connections',
    help: 'Number of active websocket connections',
  }),

  kafkaMessagesRate: new promClient.Gauge({
    name: 'trading_bot_kafka_messages_rate',
    help: 'Kafka messages per second',
  }),
};

// =============================================================================
// üéØ STRATEGY METRICS
// =============================================================================

export const strategyMetrics = {
  strategyPerformanceAccuracy: new promClient.Gauge({
    name: 'trading_bot_strategy_performance_accuracy',
    help: 'Strategy performance accuracy percentage',
    labelNames: ['strategy']
  }),

  strategyDrawdown: new promClient.Gauge({
    name: 'trading_bot_strategy_drawdown',
    help: 'Strategy maximum drawdown',
    labelNames: ['strategy']
  }),
};

// =============================================================================
// ‚ö†Ô∏è RISK MANAGEMENT METRICS
// =============================================================================

export const riskMetrics = {
  maxDrawdown: new promClient.Gauge({
    name: 'trading_bot_max_drawdown',
    help: 'Maximum portfolio drawdown percentage',
  }),

  sharpeRatio: new promClient.Gauge({
    name: 'trading_bot_sharpe_ratio',
    help: 'Portfolio Sharpe ratio',
  }),

  portfolioExposure: new promClient.Gauge({
    name: 'trading_bot_portfolio_exposure',
    help: 'Current portfolio exposure percentage',
  }),

  riskUtilization: new promClient.Gauge({
    name: 'trading_bot_risk_utilization',
    help: 'Risk utilization percentage',
  }),
};

// =============================================================================
// üí± MARKET DATA METRICS
// =============================================================================

export const marketMetrics = {
  marketPrice: new promClient.Gauge({
    name: 'trading_bot_market_price',
    help: 'Current market price for trading pairs',
    labelNames: ['symbol']
  }),

  marketVolume: new promClient.Gauge({
    name: 'trading_bot_market_volume',
    help: 'Current market volume for trading pairs',
    labelNames: ['symbol']
  }),

  priceChange: new promClient.Gauge({
    name: 'trading_bot_price_change',
    help: 'Price change percentage for trading pairs',
    labelNames: ['symbol']
  }),
};

// =============================================================================
// üìã ORDER EXECUTION METRICS
// =============================================================================

export const orderMetrics = {
  ordersExecuted: new promClient.Counter({
    name: 'trading_bot_orders_executed',
    help: 'Total orders executed',
    labelNames: ['symbol', 'side', 'type']
  }),

  ordersFailed: new promClient.Counter({
    name: 'trading_bot_orders_failed',
    help: 'Total orders failed',
    labelNames: ['symbol', 'side', 'error_type']
  }),

  orderFillRate: new promClient.Gauge({
    name: 'trading_bot_order_fill_rate',
    help: 'Order fill rate percentage',
  }),
};

// =============================================================================
// üö® HEALTH & ALERTS METRICS
// =============================================================================

export const healthMetrics = {
  componentHealth: new promClient.Gauge({
    name: 'trading_bot_component_health',
    help: 'Component health status (1=healthy, 0=unhealthy)',
    labelNames: ['component']
  }),

  alertsTriggered: new promClient.Counter({
    name: 'trading_bot_alert_triggered',
    help: 'Number of alerts triggered',
    labelNames: ['alert_type', 'severity']
  }),

  logEvents: new promClient.Counter({
    name: 'trading_bot_log_events_total',
    help: 'Total log events by level',
    labelNames: ['level']
  }),
};

// =============================================================================
// üìà UTILITY FUNCTIONS
// =============================================================================

/**
 * Update portfolio metrics
 */
export function updatePortfolioMetrics(portfolioValue: number, totalPnL: number, winRate: number) {
  tradingMetrics.portfolioValue.set(portfolioValue);
  tradingMetrics.totalPnL.set(totalPnL);
  tradingMetrics.winRate.set(winRate);
}

/**
 * Record a trade
 */
export function recordTrade(symbol: string, side: 'buy' | 'sell', profitable: boolean, strategy: string) {
  tradingMetrics.totalTrades.inc({ symbol, side });
  if (profitable) {
    tradingMetrics.profitableTrades.inc({ symbol, strategy });
  }
}

/**
 * Record a signal
 */
export function recordSignal(strategy: string, signalType: string) {
  tradingMetrics.signalsGenerated.inc({ strategy, signal_type: signalType });
  tradingMetrics.signalsByStrategy.inc({ strategy });
}

/**
 * Update market data
 */
export function updateMarketData(symbol: string, price: number, volume: number, priceChangePercent: number, latency: number) {
  marketMetrics.marketPrice.set({ symbol }, price);
  marketMetrics.marketVolume.set({ symbol }, volume);
  marketMetrics.priceChange.set({ symbol }, priceChangePercent);
  systemMetrics.marketDataLatency.observe(latency);
}

/**
 * Record order execution
 */
export function recordOrderExecution(symbol: string, side: string, type: string, executionTime: number, success: boolean) {
  if (success) {
    orderMetrics.ordersExecuted.inc({ symbol, side, type });
  } else {
    orderMetrics.ordersFailed.inc({ symbol, side, error_type: 'execution_failed' });
  }
  systemMetrics.orderExecutionTime.observe(executionTime);
}

/**
 * Update system health
 */
export function updateComponentHealth(component: string, healthy: boolean) {
  healthMetrics.componentHealth.set({ component }, healthy ? 1 : 0);
}

/**
 * Record log event
 */
export function recordLogEvent(level: string) {
  healthMetrics.logEvents.inc({ level });
}

/**
 * Update risk metrics
 */
export function updateRiskMetrics(maxDrawdown: number, sharpeRatio: number, exposure: number, riskUtil: number) {
  riskMetrics.maxDrawdown.set(maxDrawdown);
  riskMetrics.sharpeRatio.set(sharpeRatio);
  riskMetrics.portfolioExposure.set(exposure);
  riskMetrics.riskUtilization.set(riskUtil);
}

/**
 * Update system performance
 */
export function updateSystemPerformance(activePairs: number, wsConnections: number, kafkaRate: number) {
  systemMetrics.activePairs.set(activePairs);
  systemMetrics.websocketConnections.set(wsConnections);
  systemMetrics.kafkaMessagesRate.set(kafkaRate);
}

/**
 * Record trading cycle
 */
export function recordTradingCycle(duration: number) {
  systemMetrics.tradingCycleDuration.observe(duration);
}

/**
 * Trigger alert
 */
export function triggerAlert(alertType: string, severity: string) {
  healthMetrics.alertsTriggered.inc({ alert_type: alertType, severity });
}

/**
 * Get metrics for Prometheus endpoint
 */
export async function getMetrics(): Promise<string> {
  return await promClient.register.metrics();
}

/**
 * Get metrics registry
 */
export function getRegistry(): promClient.Registry {
  return promClient.register;
}

// Export all metric groups
export const allMetrics = {
  trading: tradingMetrics,
  system: systemMetrics,
  strategy: strategyMetrics,
  risk: riskMetrics,
  market: marketMetrics,
  orders: orderMetrics,
  health: healthMetrics,
};

// Initialize component health checks
const components = [
  'enterprise_data_pipeline',
  'binance_websocket',
  'kafka_streaming',
  'risk_manager',
  'portfolio_manager',
  'strategy_engine',
  'order_executor',
  'alert_system'
];

components.forEach(component => {
  updateComponentHealth(component, true);
});

console.log('üöÄ Prometheus metrics initialized for Trading Bot Dashboard');
