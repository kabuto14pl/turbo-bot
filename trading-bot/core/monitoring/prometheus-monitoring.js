"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrometheusMonitoring = void 0;
/**
 * üöÄ [PRODUCTION-OPERATIONAL]
 * Production monitoring component
 */
/**
 * üîß [SHARED-INFRASTRUCTURE]
 * Shared trading bot infrastructure
 */
const prom_client_1 = require("prom-client");
const express_1 = __importDefault(require("express"));
const events_1 = require("events");
/**
 * Production-grade monitoring system using Prometheus
 * Addresses critical gap: Distributed monitoring
 *
 * Provides:
 * - Real-time performance metrics
 * - System health monitoring
 * - Trading strategy analytics
 * - Alerting capabilities
 * - Grafana dashboard integration
 */
class PrometheusMonitoring extends events_1.EventEmitter {
    constructor(port) {
        super();
        this.server = null;
        this.port = 9090;
        this.port = port || 9090;
        this.registry = new prom_client_1.Registry();
        this.app = (0, express_1.default)();
        // Initialize all metrics
        this.initializeMetrics();
        // Setup express app
        this.setupExpressApp();
        // Collect default Node.js metrics
        (0, prom_client_1.collectDefaultMetrics)({ register: this.registry });
        console.log('üìä Prometheus monitoring initialized');
    }
    /**
     * Initialize all Prometheus metrics
     */
    initializeMetrics() {
        // Strategy Performance Metrics
        this.strategySignalsTotal = new prom_client_1.Counter({
            name: 'trading_strategy_signals_total',
            help: 'Total number of trading signals generated by strategy',
            labelNames: ['strategy', 'signal_type', 'symbol'],
            registers: [this.registry]
        });
        this.strategyExecutionsTotal = new prom_client_1.Counter({
            name: 'trading_strategy_executions_total',
            help: 'Total number of trades executed by strategy',
            labelNames: ['strategy', 'side', 'symbol', 'status'],
            registers: [this.registry]
        });
        this.strategyProfitLoss = new prom_client_1.Gauge({
            name: 'trading_strategy_profit_loss',
            help: 'Current profit/loss for each strategy',
            labelNames: ['strategy', 'symbol'],
            registers: [this.registry]
        });
        this.strategySharpeRatio = new prom_client_1.Gauge({
            name: 'trading_strategy_sharpe_ratio',
            help: 'Sharpe ratio for each strategy',
            labelNames: ['strategy'],
            registers: [this.registry]
        });
        this.strategyMaxDrawdown = new prom_client_1.Gauge({
            name: 'trading_strategy_max_drawdown',
            help: 'Maximum drawdown for each strategy',
            labelNames: ['strategy'],
            registers: [this.registry]
        });
        this.strategyWinRate = new prom_client_1.Gauge({
            name: 'trading_strategy_win_rate',
            help: 'Win rate percentage for each strategy',
            labelNames: ['strategy'],
            registers: [this.registry]
        });
        this.tradeExecutionTime = new prom_client_1.Histogram({
            name: 'trading_execution_time_seconds',
            help: 'Time taken to execute trades',
            labelNames: ['strategy', 'symbol'],
            buckets: [0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1.0, 5.0],
            registers: [this.registry]
        });
        // System Health Metrics
        this.systemCpuUsage = new prom_client_1.Gauge({
            name: 'system_cpu_usage_percent',
            help: 'Current CPU usage percentage',
            labelNames: ['component'],
            registers: [this.registry]
        });
        this.systemMemoryUsage = new prom_client_1.Gauge({
            name: 'system_memory_usage_bytes',
            help: 'Current memory usage in bytes',
            labelNames: ['type'],
            registers: [this.registry]
        });
        this.systemDiskUsage = new prom_client_1.Gauge({
            name: 'system_disk_usage_percent',
            help: 'Current disk usage percentage',
            labelNames: ['mount_point'],
            registers: [this.registry]
        });
        this.networkLatency = new prom_client_1.Histogram({
            name: 'network_latency_seconds',
            help: 'Network latency to external services',
            labelNames: ['service', 'endpoint'],
            buckets: [0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1.0],
            registers: [this.registry]
        });
        this.errorRate = new prom_client_1.Counter({
            name: 'system_errors_total',
            help: 'Total number of system errors',
            labelNames: ['component', 'error_type', 'severity'],
            registers: [this.registry]
        });
        this.systemUptime = new prom_client_1.Gauge({
            name: 'system_uptime_seconds',
            help: 'System uptime in seconds',
            registers: [this.registry]
        });
        // Risk Management Metrics
        this.portfolioValue = new prom_client_1.Gauge({
            name: 'portfolio_value_usd',
            help: 'Current portfolio value in USD',
            labelNames: ['account'],
            registers: [this.registry]
        });
        this.portfolioExposure = new prom_client_1.Gauge({
            name: 'portfolio_exposure_percent',
            help: 'Current portfolio exposure percentage',
            labelNames: ['asset_class', 'symbol'],
            registers: [this.registry]
        });
        this.riskScore = new prom_client_1.Gauge({
            name: 'risk_score',
            help: 'Current risk score (0-100)',
            labelNames: ['type'],
            registers: [this.registry]
        });
        this.positionSize = new prom_client_1.Gauge({
            name: 'position_size_usd',
            help: 'Current position size in USD',
            labelNames: ['symbol', 'side'],
            registers: [this.registry]
        });
        this.correlationRisk = new prom_client_1.Gauge({
            name: 'correlation_risk_score',
            help: 'Portfolio correlation risk score',
            labelNames: ['portfolio'],
            registers: [this.registry]
        });
        // Market Data Metrics
        this.marketDataLatency = new prom_client_1.Histogram({
            name: 'market_data_latency_seconds',
            help: 'Latency of market data updates',
            labelNames: ['exchange', 'symbol', 'feed_type'],
            buckets: [0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1.0],
            registers: [this.registry]
        });
        this.marketDataDrops = new prom_client_1.Counter({
            name: 'market_data_drops_total',
            help: 'Total number of dropped market data messages',
            labelNames: ['exchange', 'symbol', 'reason'],
            registers: [this.registry]
        });
        this.websocketConnections = new prom_client_1.Gauge({
            name: 'websocket_connections_active',
            help: 'Number of active WebSocket connections',
            labelNames: ['exchange', 'feed_type'],
            registers: [this.registry]
        });
        // Alert Metrics
        this.alertsTotal = new prom_client_1.Counter({
            name: 'alerts_total',
            help: 'Total number of alerts generated',
            labelNames: ['type', 'severity', 'component'],
            registers: [this.registry]
        });
        this.criticalAlertsTotal = new prom_client_1.Counter({
            name: 'critical_alerts_total',
            help: 'Total number of critical alerts',
            labelNames: ['component', 'alert_type'],
            registers: [this.registry]
        });
        // Trading Bot Specific Metrics for Grafana Dashboard
        this.tradingBotStatus = new prom_client_1.Gauge({
            name: 'trading_bot_status',
            help: 'Trading bot status (1 = running, 0 = stopped)',
            registers: [this.registry]
        });
        this.tradingBotPortfolioValue = new prom_client_1.Gauge({
            name: 'trading_bot_portfolio_value',
            help: 'Current portfolio value in USD',
            registers: [this.registry]
        });
        this.tradingBotTradesTotal = new prom_client_1.Counter({
            name: 'trading_bot_trades_total',
            help: 'Total number of trades executed by the bot',
            registers: [this.registry]
        });
        this.tradingBotUptime = new prom_client_1.Gauge({
            name: 'trading_bot_uptime',
            help: 'Trading bot uptime in seconds',
            registers: [this.registry]
        });
        this.tradingBotCpuUsage = new prom_client_1.Gauge({
            name: 'trading_bot_cpu_usage',
            help: 'Trading bot CPU usage percentage',
            registers: [this.registry]
        });
        this.tradingBotMemoryUsage = new prom_client_1.Gauge({
            name: 'trading_bot_memory_usage',
            help: 'Trading bot memory usage in MB',
            registers: [this.registry]
        });
        // Set initial values
        this.tradingBotStatus.set(1); // 1 = running, 0 = stopped
        this.tradingBotPortfolioValue.set(10000); // Initial portfolio value
        this.tradingBotUptime.set(0); // Will be updated dynamically
        this.tradingBotCpuUsage.set(0); // Will be updated dynamically
        this.tradingBotMemoryUsage.set(0); // Will be updated dynamically
    }
    /**
     * Setup Express app for metrics endpoint
     */
    setupExpressApp() {
        // Health check endpoint
        this.app.get('/health', (req, res) => {
            res.json({
                status: 'healthy',
                timestamp: Date.now(),
                uptime: process.uptime()
            });
        });
        // Metrics endpoint for Prometheus scraping
        this.app.get('/metrics', async (req, res) => {
            try {
                res.set('Content-Type', this.registry.contentType);
                const metrics = await this.registry.metrics();
                res.end(metrics);
            }
            catch (error) {
                console.error('‚ùå Error generating metrics:', error);
                res.status(500).end('Error generating metrics');
            }
        });
        // Custom metrics endpoint for debugging
        this.app.get('/metrics/custom', async (req, res) => {
            try {
                const customMetrics = {
                    strategyMetrics: await this.getStrategyMetrics(),
                    systemHealth: await this.getSystemHealth(),
                    riskMetrics: await this.getRiskMetrics()
                };
                res.json(customMetrics);
            }
            catch (error) {
                console.error('‚ùå Error generating custom metrics:', error);
                res.status(500).json({ error: 'Error generating custom metrics' });
            }
        });
        // AlertManager webhook endpoints
        this.app.post('/webhook/alerts', express_1.default.json(), (req, res) => {
            try {
                console.log('üì® Received AlertManager webhook:', req.body);
                this.handleAlertManagerWebhook(req.body);
                res.status(200).json({ status: 'received' });
            }
            catch (error) {
                console.error('‚ùå Error handling AlertManager webhook:', error);
                res.status(500).json({ error: 'Error processing webhook' });
            }
        });
        this.app.post('/webhook/alerts/critical', express_1.default.json(), (req, res) => {
            try {
                console.log('üö® CRITICAL AlertManager webhook:', req.body);
                this.handleAlertManagerWebhook(req.body, 'critical');
                res.status(200).json({ status: 'received' });
            }
            catch (error) {
                console.error('‚ùå Error handling critical webhook:', error);
                res.status(500).json({ error: 'Error processing webhook' });
            }
        });
        this.app.post('/webhook/alerts/emergency', express_1.default.json(), (req, res) => {
            try {
                console.log('üÜò EMERGENCY AlertManager webhook:', req.body);
                this.handleAlertManagerWebhook(req.body, 'emergency');
                res.status(200).json({ status: 'received' });
            }
            catch (error) {
                console.error('‚ùå Error handling emergency webhook:', error);
                res.status(500).json({ error: 'Error processing webhook' });
            }
        });
        this.app.post('/webhook/alerts/risk', express_1.default.json(), (req, res) => {
            try {
                console.log('‚ö†Ô∏è RISK AlertManager webhook:', req.body);
                this.handleAlertManagerWebhook(req.body, 'risk');
                res.status(200).json({ status: 'received' });
            }
            catch (error) {
                console.error('‚ùå Error handling risk webhook:', error);
                res.status(500).json({ error: 'Error processing webhook' });
            }
        });
        // üß™ TEST TRADE ENDPOINT - Generate simulated trade for testing
        this.app.post('/test/trade', express_1.default.json(), (req, res) => {
            try {
                console.log('üß™ TEST TRADE requested');
                // Generate test trade
                const testTrade = {
                    symbol: req.body.symbol || 'BTCUSDT',
                    side: req.body.side || 'buy',
                    amount: req.body.amount || 0.001,
                    price: req.body.price || 45000,
                    timestamp: Date.now()
                };
                // Update trades counter
                this.strategyExecutionsTotal.inc({
                    strategy: 'test_strategy',
                    side: testTrade.side,
                    symbol: testTrade.symbol,
                    status: 'executed'
                });
                // Update portfolio value (simulate profit)
                const portfolioChange = testTrade.side === 'buy' ? testTrade.amount * testTrade.price : -testTrade.amount * testTrade.price;
                console.log(`üß™ TEST TRADE executed: ${testTrade.side} ${testTrade.amount} ${testTrade.symbol} @ $${testTrade.price}`);
                res.status(200).json({
                    status: 'executed',
                    trade: testTrade,
                    message: 'Test trade simulated successfully'
                });
            }
            catch (error) {
                console.error('‚ùå Error executing test trade:', error);
                res.status(500).json({ error: 'Error executing test trade' });
            }
        });
    }
    /**
     * Start the monitoring server
     */
    async start() {
        return new Promise((resolve, reject) => {
            try {
                this.server = this.app.listen(this.port, '0.0.0.0', () => {
                    console.log(`üìä Prometheus monitoring server started on port ${this.port}`);
                    console.log(`üìà Metrics endpoint: http://localhost:${this.port}/metrics`);
                    console.log(`üè• Health endpoint: http://localhost:${this.port}/health`);
                    // Start collecting system metrics
                    this.startSystemMetricsCollection();
                    this.emit('started');
                    resolve();
                });
                this.server.on('error', (error) => {
                    console.error('‚ùå Monitoring server error:', error);
                    reject(error);
                });
            }
            catch (error) {
                reject(error);
            }
        });
    }
    /**
     * Stop the monitoring server
     */
    async stop() {
        return new Promise((resolve) => {
            if (this.server) {
                this.server.close(() => {
                    console.log('üìä Prometheus monitoring server stopped');
                    this.emit('stopped');
                    resolve();
                });
            }
            else {
                resolve();
            }
        });
    }
    /**
     * Record strategy signal generation
     */
    recordStrategySignal(strategy, signalType, symbol) {
        this.strategySignalsTotal.inc({ strategy, signal_type: signalType, symbol });
    }
    /**
     * Record strategy execution
     */
    recordStrategyExecution(strategy, side, symbol, status, executionTime) {
        this.strategyExecutionsTotal.inc({ strategy, side, symbol, status });
        this.tradeExecutionTime.observe({ strategy, symbol }, executionTime);
    }
    /**
     * Update strategy performance metrics
     */
    updateStrategyMetrics(metrics) {
        const { strategyName } = metrics;
        this.strategyProfitLoss.set({ strategy: strategyName, symbol: 'ALL' }, metrics.profitLoss);
        this.strategySharpeRatio.set({ strategy: strategyName }, metrics.sharpeRatio);
        this.strategyMaxDrawdown.set({ strategy: strategyName }, metrics.maxDrawdown);
        this.strategyWinRate.set({ strategy: strategyName }, metrics.winRate);
    }
    /**
     * Update system health metrics
     */
    updateSystemHealth(metrics) {
        this.systemCpuUsage.set({ component: 'trading-bot' }, metrics.cpuUsage);
        this.systemMemoryUsage.set({ type: 'used' }, metrics.memoryUsage);
        this.systemUptime.set(metrics.uptime);
    }
    /**
     * Record system error
     */
    recordError(component, errorType, severity) {
        this.errorRate.inc({ component, error_type: errorType, severity });
    }
    /**
     * Update portfolio metrics
     */
    updatePortfolioMetrics(value, exposure, riskScore) {
        this.portfolioValue.set({ account: 'main' }, value);
        this.riskScore.set({ type: 'overall' }, riskScore);
        Object.entries(exposure).forEach(([symbol, exposureValue]) => {
            this.portfolioExposure.set({ asset_class: 'crypto', symbol }, exposureValue);
        });
    }
    /**
     * Record market data latency
     */
    recordMarketDataLatency(exchange, symbol, feedType, latency) {
        this.marketDataLatency.observe({ exchange, symbol, feed_type: feedType }, latency);
    }
    /**
     * Record market data drop
     */
    recordMarketDataDrop(exchange, symbol, reason) {
        this.marketDataDrops.inc({ exchange, symbol, reason });
    }
    /**
     * Update WebSocket connection count
     */
    updateWebSocketConnections(exchange, feedType, count) {
        this.websocketConnections.set({ exchange, feed_type: feedType }, count);
    }
    /**
     * Record alert
     */
    recordAlert(type, severity, component) {
        this.alertsTotal.inc({ type, severity, component });
        if (severity === 'critical') {
            this.criticalAlertsTotal.inc({ component, alert_type: type });
        }
    }
    /**
     * Start automatic system metrics collection
     */
    startSystemMetricsCollection() {
        setInterval(() => {
            // Collect system metrics
            const memUsage = process.memoryUsage();
            const cpuUsage = process.cpuUsage();
            this.systemMemoryUsage.set({ type: 'heap_used' }, memUsage.heapUsed);
            this.systemMemoryUsage.set({ type: 'heap_total' }, memUsage.heapTotal);
            this.systemMemoryUsage.set({ type: 'external' }, memUsage.external);
            this.systemMemoryUsage.set({ type: 'rss' }, memUsage.rss);
            this.systemUptime.set(process.uptime());
        }, 5000); // Collect every 5 seconds
    }
    /**
     * Get current strategy metrics summary
     */
    async getStrategyMetrics() {
        // This would be populated with actual strategy data
        return {
            totalSignals: 0, // Would be calculated from counters
            totalExecutions: 0,
            avgProfitLoss: 0,
            avgSharpeRatio: 0
        };
    }
    /**
     * Get current system health summary
     */
    async getSystemHealth() {
        const memUsage = process.memoryUsage();
        return {
            uptime: process.uptime(),
            memory: {
                heapUsed: memUsage.heapUsed,
                heapTotal: memUsage.heapTotal,
                external: memUsage.external,
                rss: memUsage.rss
            },
            loadAverage: require('os').loadavg()
        };
    }
    /**
     * Get current risk metrics summary
     */
    async getRiskMetrics() {
        return {
            portfolioValue: 0, // Would be actual portfolio value
            riskScore: 0,
            maxExposure: 0
        };
    }
    /**
     * Get monitoring status
     */
    getStatus() {
        return {
            running: this.server !== null,
            port: this.port,
            metricsEndpoint: `http://localhost:${this.port}/metrics`,
            healthEndpoint: `http://localhost:${this.port}/health`
        };
    }
    /**
     * Handle AlertManager webhook notifications
     */
    handleAlertManagerWebhook(alertData, alertType) {
        try {
            const alerts = alertData.alerts || [];
            console.log(`üìä Processing ${alerts.length} alerts from AlertManager (type: ${alertType || 'general'})`);
            for (const alert of alerts) {
                this.processPrometheusAlert(alert, alertType);
            }
            // Emit event for other systems to handle
            this.emit('alertmanager_webhook', { alertData, alertType });
        }
        catch (error) {
            console.error('‚ùå Error processing AlertManager webhook:', error);
        }
    }
    /**
     * Process individual Prometheus alert
     */
    processPrometheusAlert(alert, alertType) {
        const alertInfo = {
            name: alert.labels?.alertname,
            severity: alert.labels?.severity,
            category: alert.labels?.category,
            status: alert.status,
            description: alert.annotations?.description,
            summary: alert.annotations?.summary,
            startsAt: alert.startsAt,
            endsAt: alert.endsAt,
            labels: alert.labels,
            type: alertType
        };
        console.log(`üîî Alert: ${alertInfo.name} (${alertInfo.severity}) - ${alertInfo.description}`);
        // Record alert metric
        this.recordAlert(alertInfo.name || 'unknown', alertInfo.severity || 'unknown', alertInfo.category || 'system');
        // Emit specific alert events
        this.emit('prometheus_alert', alertInfo);
        if (alertType === 'critical' || alertInfo.severity === 'critical') {
            this.emit('critical_alert', alertInfo);
        }
        if (alertType === 'emergency' || alertInfo.severity === 'emergency') {
            this.emit('emergency_alert', alertInfo);
        }
    }
    /**
     * Get custom metrics for external systems
     */
    async getCustomMetrics() {
        return {
            strategyMetrics: await this.getStrategyMetrics(),
            systemHealth: await this.getSystemHealth(),
            riskMetrics: await this.getRiskMetrics()
        };
    }
    /**
     * Update trading bot status
     */
    updateTradingBotStatus(status) {
        this.tradingBotStatus.set(status); // 1 = running, 0 = stopped
    }
    /**
     * Update trading bot portfolio value
     */
    updateTradingBotPortfolioValue(value) {
        this.tradingBotPortfolioValue.set(value);
    }
    /**
     * Record trading bot trade
     */
    recordTradingBotTrade() {
        this.tradingBotTradesTotal.inc();
    }
    /**
     * Update trading bot uptime
     */
    updateTradingBotUptime(uptime) {
        this.tradingBotUptime.set(uptime);
    }
    /**
     * Update trading bot system metrics
     */
    updateTradingBotSystemMetrics(cpuUsage, memoryUsage) {
        this.tradingBotCpuUsage.set(cpuUsage);
        this.tradingBotMemoryUsage.set(memoryUsage);
    }
}
exports.PrometheusMonitoring = PrometheusMonitoring;
// Export default instance
exports.default = new PrometheusMonitoring();
