/**
 * ðŸš€ PERFORMANCE TRACKER
 * Comprehensive performance monitoring and metrics calculation
 */

import { EventEmitter } from 'events';
import { Logger } from '../utils/logger';
import { Signal } from '../types';

export interface TradingDecision {
    type: 'buy' | 'sell' | 'hold';
    size: number;
    price: number;
    timestamp: number;
    confidence: number;
    symbol?: string;
    action?: 'BUY' | 'SELL';
    quantity?: number;
    strategy?: string;
}

export interface PerformanceMetrics {
    totalReturn: number;
    annualizedReturn: number;
    volatility: number;
    sharpeRatio: number;
    maxDrawdown: number;
    winRate: number;
    profitFactor: number;
    totalTrades: number;
    avgTradeDuration: number;
    averageWin: number;
    averageLoss: number;
    calmarRatio: number;
    sortinoRatio: number;
    winningTrades: number;
    losingTrades: number;
    largestWin: number;
    largestLoss: number;
    averageHoldingPeriod: number;
    lastUpdated: number;
    // ðŸš€ Sentiment Performance Metrics
    sentimentMetrics?: {
        blockedTrades: number;
        sentimentSavedLosses: number;
        averageSentimentScore: number;
        sentimentAccuracy: number;
        sentimentProfitImpact: number;
        highSentimentWinRate: number;
        lowSentimentWinRate: number;
        sentimentVsActualCorrelation: number;
    };
}

export interface Trade {
    id: string;
    symbol: string;
    side: 'BUY' | 'SELL';
    quantity: number;
    entryPrice: number;
    exitPrice?: number;
    entryTime: Date;
    exitTime?: Date;
    pnl?: number;
    commission: number;
    strategy: string;
    status: 'OPEN' | 'CLOSED';
    // ðŸš€ Sentiment tracking data
    sentimentData?: {
        entrysentiment: number;
        exitSentiment?: number;
        wasBlocked: boolean;
        sentimentSource: 'news' | 'social' | 'technical' | 'composite';
        blockedReason?: string;
        savedLossEstimate?: number;
    };
}

export interface PerformanceWindow {
    startTime: Date;
    endTime: Date;
    metrics: PerformanceMetrics;
    trades: Trade[];
    portfolioValue: number[];
    benchmarkReturn?: number;
}

export class PerformanceTracker extends EventEmitter {
    private logger: Logger;
    private trades: Trade[] = [];
    private portfolioHistory: { timestamp: Date; value: number }[] = [];
    private initialCapital: number;
    private currentCapital: number;
    private openPositions: Map<string, Trade> = new Map();
    private performanceWindows: PerformanceWindow[] = [];
    private riskFreeRate: number = 0.02; // 2% annual risk-free rate
    
    constructor(initialCapital: number = 100000) {
        super();
                this.logger = new Logger();
        this.initialCapital = initialCapital;
        this.currentCapital = initialCapital;
        
        this.logger.info(`Performance tracker initialized with capital: $${initialCapital}`);
    }
    
    /**
     * Record a new trade
     */
    recordTrade(decision: TradingDecision, price?: number): string {
        const tradeId = `trade_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        const trade: Trade = {
            id: tradeId,
            symbol: decision.symbol || 'UNKNOWN',
            side: decision.action as 'BUY' | 'SELL' || 'BUY',
            quantity: decision.quantity || decision.size,
            entryPrice: price || decision.price,
            entryTime: new Date(decision.timestamp),
            commission: this.calculateCommission(decision.quantity || decision.size, price || decision.price),
            strategy: decision.strategy || 'UNKNOWN',
            status: 'OPEN' as const
        };
        
        this.trades.push(trade);
        this.openPositions.set(tradeId, trade);
        
        this.logger.debug(`Trade recorded: ${trade.side} ${trade.quantity} ${trade.symbol} at $${trade.entryPrice}`);
        this.emit('tradeOpened', trade);
        
        return tradeId;
    }
    
    /**
     * Close a trade
     */
    closeTrade(tradeId: string, exitPrice: number, exitTime?: Date): boolean {
        const trade = this.openPositions.get(tradeId);
        if (!trade) {
            this.logger.warn(`Attempt to close non-existent trade: ${tradeId}`);
            return false;
        }
        
        trade.exitPrice = exitPrice;
        trade.exitTime = exitTime || new Date();
        trade.status = 'CLOSED';
        
        // Calculate P&L
        const priceChange = trade.side === 'BUY' 
            ? exitPrice - trade.entryPrice 
            : trade.entryPrice - exitPrice;
        
        trade.pnl = (priceChange * trade.quantity) - trade.commission;
        
        this.currentCapital += trade.pnl;
        this.openPositions.delete(tradeId);
        
        this.logger.debug(`Trade closed: ${tradeId}, P&L: $${trade.pnl?.toFixed(2)}`);
        this.emit('tradeClosed', trade);
        
        return true;
    }
    
    /**
     * Update portfolio value
     */
    updatePortfolioValue(value: number): void {
        this.portfolioHistory.push({
            timestamp: new Date(),
            value: value
        });
        
        this.currentCapital = value;
        this.emit('portfolioUpdated', { value, timestamp: new Date() });
    }
    
    /**
     * Calculate current performance metrics
     */
    calculateMetrics(windowDays?: number): PerformanceMetrics {
        const relevantTrades = windowDays 
            ? this.getTradesInWindow(windowDays)
            : this.trades.filter(t => t.status === 'CLOSED');
        
        if (relevantTrades.length === 0) {
            return this.getEmptyMetrics();
        }
        
        const returns = this.calculateReturns(relevantTrades);
        const totalReturn = this.calculateTotalReturn();
        const sharpeRatio = this.calculateSharpeRatio(returns);
        const maxDrawdown = this.calculateMaxDrawdown();
        const winRate = this.calculateWinRate(relevantTrades);
        
        const winningTrades = relevantTrades.filter(t => (t.pnl || 0) > 0);
        const losingTrades = relevantTrades.filter(t => (t.pnl || 0) < 0);
        
        const averageWin = winningTrades.length > 0 
            ? winningTrades.reduce((sum, t) => sum + (t.pnl || 0), 0) / winningTrades.length
            : 0;
        
        const averageLoss = losingTrades.length > 0
            ? Math.abs(losingTrades.reduce((sum, t) => sum + (t.pnl || 0), 0) / losingTrades.length)
            : 0;
        
        const profitFactor = averageLoss > 0 ? averageWin / averageLoss : 0;
        const volatility = this.calculateVolatility(returns);
        const calmarRatio = maxDrawdown > 0 ? totalReturn / maxDrawdown : 0;
        const sortinoRatio = this.calculateSortinoRatio(returns);
        
        return {
            totalReturn,
            annualizedReturn: returns.length > 0 ? (returns.reduce((sum, r) => sum + r, 0) / returns.length) * 252 : 0,
            volatility,
            sharpeRatio,
            maxDrawdown,
            winRate,
            profitFactor,
            totalTrades: relevantTrades.length,
            avgTradeDuration: this.calculateAverageHoldingPeriod(relevantTrades),
            averageWin,
            averageLoss,
            calmarRatio,
            sortinoRatio,
            winningTrades: winningTrades.length,
            losingTrades: losingTrades.length,
            largestWin: winningTrades.length > 0 ? Math.max(...winningTrades.map(t => t.pnl || 0)) : 0,
            largestLoss: losingTrades.length > 0 ? Math.min(...losingTrades.map(t => t.pnl || 0)) : 0,
            averageHoldingPeriod: this.calculateAverageHoldingPeriod(relevantTrades),
            lastUpdated: Date.now()
        };
    }

    // ðŸš€ SENTIMENT PERFORMANCE TRACKING METHODS

    /**
     * Record a sentiment-blocked trade for analysis
     */
    recordBlockedTrade(
        symbol: string,
        side: 'BUY' | 'SELL',
        quantity: number,
        price: number,
        sentimentScore: number,
        reason: string,
        strategy: string
    ): void {
        const blockedTrade: Trade = {
            id: `blocked_${Date.now()}_${Math.random()}`,
            symbol,
            side,
            quantity,
            entryPrice: price,
            entryTime: new Date(),
            commission: 0,
            strategy,
            status: 'CLOSED',
            pnl: 0,
            sentimentData: {
                entrysentiment: sentimentScore,
                wasBlocked: true,
                sentimentSource: 'composite',
                blockedReason: reason,
                savedLossEstimate: this.estimateSavedLoss(symbol, side, price)
            }
        };

        this.trades.push(blockedTrade);
        this.logger.info(`Recorded blocked trade: ${symbol} ${side} at ${price}, sentiment: ${sentimentScore}, reason: ${reason}`);
    }

    /**
     * Record a completed trade with all details
     */
    recordCompletedTrade(trade: Trade): void {
        this.trades.push(trade);
        this.logger.info(`Recorded completed trade: ${trade.id} ${trade.symbol} ${trade.side} PnL: ${trade.pnl || 0}`);
    }

    /**
     * Add sentiment data to existing trade
     */
    addSentimentDataToTrade(
        tradeId: string,
        entrysentiment: number,
        exitSentiment?: number,
        source: 'news' | 'social' | 'technical' | 'composite' = 'composite'
    ): void {
        const trade = this.trades.find(t => t.id === tradeId);
        if (trade) {
            trade.sentimentData = {
                entrysentiment,
                exitSentiment,
                wasBlocked: false,
                sentimentSource: source
            };
            this.logger.debug(`Added sentiment data to trade ${tradeId}: entry=${entrysentiment}, exit=${exitSentiment || 'N/A'}`);
        }
    }

    /**
     * Calculate sentiment performance metrics
     */
    calculateSentimentMetrics(): PerformanceMetrics['sentimentMetrics'] {
        const tradesWithSentiment = this.trades.filter(t => t.sentimentData);
        
        if (tradesWithSentiment.length === 0) {
            return {
                blockedTrades: 0,
                sentimentSavedLosses: 0,
                averageSentimentScore: 0,
                sentimentAccuracy: 0,
                sentimentProfitImpact: 0,
                highSentimentWinRate: 0,
                lowSentimentWinRate: 0,
                sentimentVsActualCorrelation: 0
            };
        }

        const blockedTrades = tradesWithSentiment.filter(t => t.sentimentData!.wasBlocked);
        const executedTrades = tradesWithSentiment.filter(t => !t.sentimentData!.wasBlocked);
        
        // Calculate saved losses from blocked trades
        const sentimentSavedLosses = blockedTrades.reduce((sum, t) => 
            sum + (t.sentimentData!.savedLossEstimate || 0), 0);

        // Average sentiment score
        const averageSentimentScore = tradesWithSentiment.reduce((sum, t) => 
            sum + t.sentimentData!.entrysentiment, 0) / tradesWithSentiment.length;

        // High vs Low sentiment performance
        const highSentimentTrades = executedTrades.filter(t => t.sentimentData!.entrysentiment > 0.6);
        const lowSentimentTrades = executedTrades.filter(t => t.sentimentData!.entrysentiment < 0.4);
        
        const highSentimentWinRate = highSentimentTrades.length > 0
            ? highSentimentTrades.filter(t => (t.pnl || 0) > 0).length / highSentimentTrades.length
            : 0;

        const lowSentimentWinRate = lowSentimentTrades.length > 0
            ? lowSentimentTrades.filter(t => (t.pnl || 0) > 0).length / lowSentimentTrades.length
            : 0;

        // Sentiment accuracy (how well sentiment predicted actual outcome)
        const sentimentAccuracy = this.calculateSentimentAccuracy(executedTrades);
        
        // Sentiment profit impact
        const sentimentProfitImpact = this.calculateSentimentProfitImpact(executedTrades);

        // Correlation between sentiment and actual results
        const sentimentVsActualCorrelation = this.calculateSentimentCorrelation(executedTrades);

        return {
            blockedTrades: blockedTrades.length,
            sentimentSavedLosses,
            averageSentimentScore,
            sentimentAccuracy,
            sentimentProfitImpact,
            highSentimentWinRate,
            lowSentimentWinRate,
            sentimentVsActualCorrelation
        };
    }

    /**
     * Get comprehensive sentiment performance report
     */
    getSentimentPerformanceReport(): {
        summary: PerformanceMetrics['sentimentMetrics'];
        insights: string[];
        recommendations: string[];
    } {
        const summary = this.calculateSentimentMetrics();
        const insights: string[] = [];
        const recommendations: string[] = [];

        if (!summary) return { summary, insights, recommendations };

        // Generate insights
        if (summary.blockedTrades > 0) {
            insights.push(`ðŸ›¡ï¸ Sentiment analysis blocked ${summary.blockedTrades} potentially losing trades`);
            if (summary.sentimentSavedLosses > 0) {
                insights.push(`ðŸ’° Estimated saved losses: $${summary.sentimentSavedLosses.toFixed(2)}`);
            }
        }

        if (summary.highSentimentWinRate > summary.lowSentimentWinRate) {
            insights.push(`ðŸ“ˆ High sentiment trades perform better: ${(summary.highSentimentWinRate * 100).toFixed(1)}% vs ${(summary.lowSentimentWinRate * 100).toFixed(1)}% win rate`);
        }

        if (summary.sentimentAccuracy > 0.6) {
            insights.push(`ðŸŽ¯ Sentiment predictions are accurate: ${(summary.sentimentAccuracy * 100).toFixed(1)}%`);
        } else if (summary.sentimentAccuracy < 0.4) {
            insights.push(`âš ï¸ Sentiment predictions need improvement: ${(summary.sentimentAccuracy * 100).toFixed(1)}% accuracy`);
        }

        // Generate recommendations
        if (summary.sentimentAccuracy < 0.5) {
            recommendations.push("ðŸ”§ Consider adjusting sentiment analysis thresholds");
        }

        if (summary.lowSentimentWinRate > summary.highSentimentWinRate) {
            recommendations.push("ðŸ”„ Review sentiment scoring algorithm - low sentiment trades performing better");
        }

        if (summary.sentimentProfitImpact > 0.1) {
            recommendations.push("ðŸ“Š Sentiment analysis is providing significant value - maintain current approach");
        } else if (summary.sentimentProfitImpact < 0.05) {
            recommendations.push("âš¡ Consider increasing sentiment weight in trading decisions");
        }

        return { summary, insights, recommendations };
    }

    // Helper methods for sentiment calculations
    private estimateSavedLoss(symbol: string, side: 'BUY' | 'SELL', price: number): number {
        // Simple estimation based on average loss for similar trades
        const similarTrades = this.trades.filter(t => 
            t.symbol === symbol && 
            t.side === side && 
            t.status === 'CLOSED' && 
            (t.pnl || 0) < 0
        );

        if (similarTrades.length === 0) return 0;

        const averageLoss = Math.abs(similarTrades.reduce((sum, t) => sum + (t.pnl || 0), 0) / similarTrades.length);
        return averageLoss * 0.7; // Conservative estimate
    }

    private calculateSentimentAccuracy(trades: Trade[]): number {
        let correctPredictions = 0;
        
        for (const trade of trades) {
            if (!trade.sentimentData || trade.pnl === undefined) continue;
            
            const sentiment = trade.sentimentData.entrysentiment;
            const actualProfit = trade.pnl > 0;
            const predictedProfit = sentiment > 0.5;
            
            if (predictedProfit === actualProfit) {
                correctPredictions++;
            }
        }
        
        return trades.length > 0 ? correctPredictions / trades.length : 0;
    }

    private calculateSentimentProfitImpact(trades: Trade[]): number {
        if (trades.length === 0) return 0;
        
        const totalPnl = trades.reduce((sum, t) => sum + (t.pnl || 0), 0);
        const sentimentWeightedPnl = trades.reduce((sum, t) => {
            const sentiment = t.sentimentData?.entrysentiment || 0.5;
            return sum + (t.pnl || 0) * sentiment;
        }, 0);
        
        return Math.abs(totalPnl) > 0 ? Math.abs(sentimentWeightedPnl - totalPnl) / Math.abs(totalPnl) : 0;
    }

    private calculateSentimentCorrelation(trades: Trade[]): number {
        if (trades.length < 2) return 0;
        
        const sentiments = trades.map(t => t.sentimentData?.entrysentiment || 0.5);
        const returns = trades.map(t => t.pnl || 0);
        
        return this.calculateCorrelation(sentiments, returns);
    }

    private calculateCorrelation(x: number[], y: number[]): number {
        const n = x.length;
        if (n === 0) return 0;
        
        const sumX = x.reduce((a, b) => a + b, 0);
        const sumY = y.reduce((a, b) => a + b, 0);
        const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
        const sumXX = x.reduce((sum, xi) => sum + xi * xi, 0);
        const sumYY = y.reduce((sum, yi) => sum + yi * yi, 0);
        
        const numerator = n * sumXY - sumX * sumY;
        const denominator = Math.sqrt((n * sumXX - sumX * sumX) * (n * sumYY - sumY * sumY));
        
        return denominator === 0 ? 0 : numerator / denominator;
    }

    /**
     * Get performance trend analysis
     */
    getPerformanceTrend(periods: number = 10): { 
        improving: boolean; 
        trend: number; 
        confidence: number;
        recentMetrics: PerformanceMetrics;
    } {
        if (this.trades.length < periods) {
            return { 
                improving: false, 
                trend: 0, 
                confidence: 0,
                recentMetrics: this.getEmptyMetrics()
            };
        }
        
        const recentTrades = this.trades.slice(-periods);
        const recentMetrics = this.calculateMetricsForTrades(recentTrades);
        
        // Calculate trend based on recent performance windows
        const windowSize = Math.max(5, Math.floor(periods / 3));
        const windows = [];
        
        for (let i = windowSize; i <= periods; i += windowSize) {
            const windowTrades = recentTrades.slice(-i, -i + windowSize);
            if (windowTrades.length > 0) {
                windows.push(this.calculateMetricsForTrades(windowTrades));
            }
        }
        
        if (windows.length < 2) {
            return { 
                improving: false, 
                trend: 0, 
                confidence: 0.5,
                recentMetrics
            };
        }
        
        // Calculate trend slope based on Sharpe ratio improvement
        const trendPoints = windows.map((w, i) => ({ x: i, y: w.sharpeRatio }));
        const trend = this.calculateLinearTrend(trendPoints);
        const improving = trend > 0;
        const confidence = Math.min(1, Math.abs(trend) * windows.length / 10);
        
        return { improving, trend, confidence, recentMetrics };
    }
    
    /**
     * Check if optimization is needed based on performance
     */
    shouldOptimize(thresholds: {
        sharpeRatio?: number;
        maxDrawdown?: number;
        winRate?: number;
        lookbackPeriods?: number;
    } = {}): { needed: boolean; reasons: string[]; metrics: PerformanceMetrics } {
        const {
            sharpeRatio: minSharpe = 1.0,
            maxDrawdown: maxDD = 0.15,
            winRate: minWinRate = 0.45,
            lookbackPeriods = 50
        } = thresholds;
        
        const metrics = this.calculateMetrics(lookbackPeriods);
        const reasons: string[] = [];
        
        if (metrics.sharpeRatio < minSharpe) {
            reasons.push(`Sharpe ratio (${metrics.sharpeRatio.toFixed(2)}) below threshold (${minSharpe})`);
        }
        
        if (metrics.maxDrawdown > maxDD) {
            reasons.push(`Max drawdown (${(metrics.maxDrawdown * 100).toFixed(1)}%) exceeds threshold (${(maxDD * 100).toFixed(1)}%)`);
        }
        
        if (metrics.winRate < minWinRate) {
            reasons.push(`Win rate (${(metrics.winRate * 100).toFixed(1)}%) below threshold (${(minWinRate * 100).toFixed(1)}%)`);
        }
        
        const needed = reasons.length > 0;
        
        if (needed) {
            this.logger.info(`Optimization recommended: ${reasons.join(', ')}`);
        }
        
        return { needed, reasons, metrics };
    }
    
    /**
     * Get comprehensive performance report
     */
    getPerformanceReport(): {
        summary: PerformanceMetrics;
        trend: any;
        optimization: any;
        trades: {
            total: number;
            open: number;
            closed: number;
            recent: Trade[];
        };
        portfolio: {
            current: number;
            initial: number;
            change: number;
            changePercent: number;
        };
    } {
        const summary = this.calculateMetrics();
        const trend = this.getPerformanceTrend();
        const optimization = this.shouldOptimize();
        
        return {
            summary,
            trend,
            optimization,
            trades: {
                total: this.trades.length,
                open: this.openPositions.size,
                closed: this.trades.filter(t => t.status === 'CLOSED').length,
                recent: this.trades.slice(-10)
            },
            portfolio: {
                current: this.currentCapital,
                initial: this.initialCapital,
                change: this.currentCapital - this.initialCapital,
                changePercent: (this.currentCapital - this.initialCapital) / this.initialCapital
            }
        };
    }
    
    // Private helper methods
    private calculateCommission(quantity: number, price: number): number {
        return quantity * price * 0.001; // 0.1% commission
    }
    
    private getTradesInWindow(days: number): Trade[] {
        const cutoffDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);
        return this.trades.filter(t => 
            t.status === 'CLOSED' && 
            t.exitTime && 
            t.exitTime >= cutoffDate
        );
    }
    
    private calculateReturns(trades: Trade[]): number[] {
        return trades
            .filter(t => t.pnl !== undefined)
            .map(t => (t.pnl || 0) / this.initialCapital);
    }
    
    private calculateTotalReturn(): number {
        return (this.currentCapital - this.initialCapital) / this.initialCapital;
    }
    
    private calculateSharpeRatio(returns: number[]): number {
        if (returns.length === 0) return 0;
        
        const avgReturn = returns.reduce((sum, r) => sum + r, 0) / returns.length;
        const variance = returns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / returns.length;
        const stdDev = Math.sqrt(variance);
        
        if (stdDev === 0) return 0;
        
        // Annualized Sharpe ratio
        const annualizedReturn = avgReturn * 252; // 252 trading days
        const annualizedStdDev = stdDev * Math.sqrt(252);
        
        return (annualizedReturn - this.riskFreeRate) / annualizedStdDev;
    }
    
    private calculateMaxDrawdown(): number {
        if (this.portfolioHistory.length < 2) return 0;
        
        let maxDrawdown = 0;
        let peak = this.portfolioHistory[0].value;
        
        for (const point of this.portfolioHistory) {
            if (point.value > peak) {
                peak = point.value;
            }
            
            const drawdown = (peak - point.value) / peak;
            maxDrawdown = Math.max(maxDrawdown, drawdown);
        }
        
        return maxDrawdown;
    }
    
    private calculateWinRate(trades: Trade[]): number {
        const closedTrades = trades.filter(t => t.status === 'CLOSED' && t.pnl !== undefined);
        if (closedTrades.length === 0) return 0;
        
        const winningTrades = closedTrades.filter(t => (t.pnl || 0) > 0);
        return winningTrades.length / closedTrades.length;
    }
    
    private calculateVolatility(returns: number[]): number {
        if (returns.length === 0) return 0;
        
        const avgReturn = returns.reduce((sum, r) => sum + r, 0) / returns.length;
        const variance = returns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / returns.length;
        
        return Math.sqrt(variance * 252); // Annualized volatility
    }
    
    private calculateSortinoRatio(returns: number[]): number {
        if (returns.length === 0) return 0;
        
        const avgReturn = returns.reduce((sum, r) => sum + r, 0) / returns.length;
        const negativeReturns = returns.filter(r => r < 0);
        
        if (negativeReturns.length === 0) return Infinity;
        
        const downwardDeviation = Math.sqrt(
            negativeReturns.reduce((sum, r) => sum + Math.pow(r, 2), 0) / negativeReturns.length
        );
        
        const annualizedReturn = avgReturn * 252;
        const annualizedDownwardDev = downwardDeviation * Math.sqrt(252);
        
        return (annualizedReturn - this.riskFreeRate) / annualizedDownwardDev;
    }
    
    private calculateAverageHoldingPeriod(trades: Trade[]): number {
        const closedTrades = trades.filter(t => t.status === 'CLOSED' && t.exitTime);
        if (closedTrades.length === 0) return 0;
        
        const totalHours = closedTrades.reduce((sum, t) => {
            const holdingTime = (t.exitTime!.getTime() - t.entryTime.getTime()) / (1000 * 60 * 60);
            return sum + holdingTime;
        }, 0);
        
        return totalHours / closedTrades.length;
    }
    
    private calculateMetricsForTrades(trades: Trade[]): PerformanceMetrics {
        const closedTrades = trades.filter(t => t.status === 'CLOSED');
        if (closedTrades.length === 0) return this.getEmptyMetrics();
        
        const returns = this.calculateReturns(closedTrades);
        const winningTrades = closedTrades.filter(t => (t.pnl || 0) > 0);
        const losingTrades = closedTrades.filter(t => (t.pnl || 0) < 0);
        
        return {
            totalReturn: returns.reduce((sum, r) => sum + r, 0),
            annualizedReturn: returns.length > 0 ? (returns.reduce((sum, r) => sum + r, 0) / returns.length) * 252 : 0,
            volatility: this.calculateVolatility(returns),
            sharpeRatio: this.calculateSharpeRatio(returns),
            maxDrawdown: 0, // Simplified for individual trade windows
            winRate: winningTrades.length / closedTrades.length,
            profitFactor: (losingTrades.length > 0
                ? (winningTrades.length > 0
                    ? (winningTrades.reduce((sum, t) => sum + (t.pnl || 0), 0) / winningTrades.length) /
                      Math.abs(losingTrades.reduce((sum, t) => sum + (t.pnl || 0), 0) / losingTrades.length)
                    : 0)
                : 0),
            totalTrades: closedTrades.length,
            avgTradeDuration: this.calculateAverageHoldingPeriod(closedTrades),
            averageWin: winningTrades.length > 0 
                ? winningTrades.reduce((sum, t) => sum + (t.pnl || 0), 0) / winningTrades.length
                : 0,
            averageLoss: losingTrades.length > 0
                ? Math.abs(losingTrades.reduce((sum, t) => sum + (t.pnl || 0), 0) / losingTrades.length)
                : 0,
            calmarRatio: 0,
            sortinoRatio: this.calculateSortinoRatio(returns),
            winningTrades: winningTrades.length,
            losingTrades: losingTrades.length,
            largestWin: winningTrades.length > 0 ? Math.max(...winningTrades.map(t => t.pnl || 0)) : 0,
            largestLoss: losingTrades.length > 0 ? Math.min(...losingTrades.map(t => t.pnl || 0)) : 0,
            averageHoldingPeriod: this.calculateAverageHoldingPeriod(closedTrades),
            lastUpdated: Date.now()
        };
    }
    
    private calculateLinearTrend(points: { x: number; y: number }[]): number {
        const n = points.length;
        if (n < 2) return 0;
        
        const sumX = points.reduce((sum, p) => sum + p.x, 0);
        const sumY = points.reduce((sum, p) => sum + p.y, 0);
        const sumXY = points.reduce((sum, p) => sum + p.x * p.y, 0);
        const sumXX = points.reduce((sum, p) => sum + p.x * p.x, 0);
        
        const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
        return slope;
    }
    
    private getEmptyMetrics(): PerformanceMetrics {
        return {
            totalReturn: 0,
            annualizedReturn: 0,
            volatility: 0,
            sharpeRatio: 0,
            maxDrawdown: 0,
            winRate: 0,
            profitFactor: 0,
            totalTrades: 0,
            avgTradeDuration: 0,
            averageWin: 0,
            averageLoss: 0,
            calmarRatio: 0,
            sortinoRatio: 0,
            winningTrades: 0,
            losingTrades: 0,
            largestWin: 0,
            largestLoss: 0,
            averageHoldingPeriod: 0,
            lastUpdated: Date.now()
        };
    }
}
        symbol: string,
        side: 'BUY' | 'SELL',
        quantity: number,
        price: number,
        sentimentScore: number,
        reason: string,
        strategy: string
    ): void {
        const blockedTrade: Trade = {
            id: `blocked_${Date.now()}_${Math.random()}`,
            symbol,
            side,
            quantity,
            entryPrice: price,
            entryTime: new Date(),
            commission: 0,
            strategy,
            status: 'CLOSED',
            pnl: 0,
            sentimentData: {
                entrysentiment: sentimentScore,
                wasBlocked: true,
                sentimentSource: 'composite',
                blockedReason: reason,
                savedLossEstimate: this.estimateSavedLoss(symbol, side, price)
            }
        };

        this.trades.push(blockedTrade);
        this.logger.info(`Recorded blocked trade: ${symbol} ${side} at ${price}, sentiment: ${sentimentScore}, reason: ${reason}`);
    }

    /**
     * Record a completed trade with all details
     */
    recordCompletedTrade(trade: Trade): void {
        this.trades.push(trade);
        this.logger.info(`Recorded completed trade: ${trade.id} ${trade.symbol} ${trade.side} PnL: ${trade.pnl || 0}`);
    }

    /**
     * Add sentiment data to existing trade
     */
    addSentimentDataToTrade(
        tradeId: string,
        entrysentiment: number,
        exitSentiment?: number,
        source: 'news' | 'social' | 'technical' | 'composite' = 'composite'
    ): void {
        const trade = this.trades.find(t => t.id === tradeId);
        if (trade) {
            trade.sentimentData = {
                entrysentiment,
                exitSentiment,
                wasBlocked: false,
                sentimentSource: source
            };
            this.logger.debug(`Added sentiment data to trade ${tradeId}: entry=${entrysentiment}, exit=${exitSentiment || 'N/A'}`);
        }
    }

    /**
     * Calculate sentiment performance metrics
     */
    calculateSentimentMetrics(): PerformanceMetrics['sentimentMetrics'] {
        const tradesWithSentiment = this.trades.filter(t => t.sentimentData);
        
        if (tradesWithSentiment.length === 0) {
            return {
                blockedTrades: 0,
                sentimentSavedLosses: 0,
                averageSentimentScore: 0,
                sentimentAccuracy: 0,
                sentimentProfitImpact: 0,
                highSentimentWinRate: 0,
                lowSentimentWinRate: 0,
                sentimentVsActualCorrelation: 0
            };
        }

        const blockedTrades = tradesWithSentiment.filter(t => t.sentimentData!.wasBlocked);
        const executedTrades = tradesWithSentiment.filter(t => !t.sentimentData!.wasBlocked);
        
        // Calculate saved losses from blocked trades
        const sentimentSavedLosses = blockedTrades.reduce((sum, t) => 
            sum + (t.sentimentData!.savedLossEstimate || 0), 0);

        // Average sentiment score
        const averageSentimentScore = tradesWithSentiment.reduce((sum, t) => 
            sum + t.sentimentData!.entrysentiment, 0) / tradesWithSentiment.length;

        // High vs Low sentiment performance
        const highSentimentTrades = executedTrades.filter(t => t.sentimentData!.entrysentiment > 0.6);
        const lowSentimentTrades = executedTrades.filter(t => t.sentimentData!.entrysentiment < 0.4);
        
        const highSentimentWinRate = highSentimentTrades.length > 0
            ? highSentimentTrades.filter(t => (t.pnl || 0) > 0).length / highSentimentTrades.length
            : 0;

        const lowSentimentWinRate = lowSentimentTrades.length > 0
            ? lowSentimentTrades.filter(t => (t.pnl || 0) > 0).length / lowSentimentTrades.length
            : 0;

        // Sentiment accuracy (how well sentiment predicted actual outcome)
        const sentimentAccuracy = this.calculateSentimentAccuracy(executedTrades);
        
        // Sentiment profit impact
        const sentimentProfitImpact = this.calculateSentimentProfitImpact(executedTrades);

        // Correlation between sentiment and actual results
        const sentimentVsActualCorrelation = this.calculateSentimentCorrelation(executedTrades);

        return {
            blockedTrades: blockedTrades.length,
            sentimentSavedLosses,
            averageSentimentScore,
            sentimentAccuracy,
            sentimentProfitImpact,
            highSentimentWinRate,
            lowSentimentWinRate,
            sentimentVsActualCorrelation
        };
    }

    /**
     * Get comprehensive sentiment performance report
     */
    getSentimentPerformanceReport(): {
        summary: PerformanceMetrics['sentimentMetrics'];
        insights: string[];
        recommendations: string[];
    } {
        const summary = this.calculateSentimentMetrics();
        const insights: string[] = [];
        const recommendations: string[] = [];

        if (!summary) return { summary, insights, recommendations };

        // Generate insights
        if (summary.blockedTrades > 0) {
            insights.push(`ðŸ›¡ï¸ Sentiment analysis blocked ${summary.blockedTrades} potentially losing trades`);
            if (summary.sentimentSavedLosses > 0) {
                insights.push(`ðŸ’° Estimated saved losses: $${summary.sentimentSavedLosses.toFixed(2)}`);
            }
        }

        if (summary.highSentimentWinRate > summary.lowSentimentWinRate) {
            insights.push(`ðŸ“ˆ High sentiment trades perform better: ${(summary.highSentimentWinRate * 100).toFixed(1)}% vs ${(summary.lowSentimentWinRate * 100).toFixed(1)}% win rate`);
        }

        if (summary.sentimentAccuracy > 0.6) {
            insights.push(`ðŸŽ¯ Sentiment predictions are accurate: ${(summary.sentimentAccuracy * 100).toFixed(1)}%`);
        } else if (summary.sentimentAccuracy < 0.4) {
            insights.push(`âš ï¸ Sentiment predictions need improvement: ${(summary.sentimentAccuracy * 100).toFixed(1)}% accuracy`);
        }

        // Generate recommendations
        if (summary.sentimentAccuracy < 0.5) {
            recommendations.push("ðŸ”§ Consider adjusting sentiment analysis thresholds");
        }

        if (summary.lowSentimentWinRate > summary.highSentimentWinRate) {
            recommendations.push("ðŸ”„ Review sentiment scoring algorithm - low sentiment trades performing better");
        }

        if (summary.sentimentProfitImpact > 0.1) {
            recommendations.push("ðŸ“Š Sentiment analysis is providing significant value - maintain current approach");
        } else if (summary.sentimentProfitImpact < 0.05) {
            recommendations.push("âš¡ Consider increasing sentiment weight in trading decisions");
        }

        return { summary, insights, recommendations };
    }

    // Helper methods for sentiment calculations
    private estimateSavedLoss(symbol: string, side: 'BUY' | 'SELL', price: number): number {
        // Simple estimation based on average loss for similar trades
        const similarTrades = this.trades.filter(t => 
            t.symbol === symbol && 
            t.side === side && 
            t.status === 'CLOSED' && 
            (t.pnl || 0) < 0
        );

        if (similarTrades.length === 0) return 0;

        const averageLoss = Math.abs(similarTrades.reduce((sum, t) => sum + (t.pnl || 0), 0) / similarTrades.length);
        return averageLoss * 0.7; // Conservative estimate
    }

    private calculateSentimentAccuracy(trades: Trade[]): number {
        let correctPredictions = 0;
        
        for (const trade of trades) {
            if (!trade.sentimentData || trade.pnl === undefined) continue;
            
            const sentiment = trade.sentimentData.entrysentiment;
            const actualProfit = trade.pnl > 0;
            const predictedProfit = sentiment > 0.5;
            
            if (predictedProfit === actualProfit) {
                correctPredictions++;
            }
        }
        
        return trades.length > 0 ? correctPredictions / trades.length : 0;
    }

    private calculateSentimentProfitImpact(trades: Trade[]): number {
        if (trades.length === 0) return 0;
        
        const totalPnl = trades.reduce((sum, t) => sum + (t.pnl || 0), 0);
        const sentimentWeightedPnl = trades.reduce((sum, t) => {
            const sentiment = t.sentimentData?.entrysentiment || 0.5;
            return sum + (t.pnl || 0) * sentiment;
        }, 0);
        
        return Math.abs(totalPnl) > 0 ? Math.abs(sentimentWeightedPnl - totalPnl) / Math.abs(totalPnl) : 0;
    }

    private calculateSentimentCorrelation(trades: Trade[]): number {
        if (trades.length < 2) return 0;
        
        const sentiments = trades.map(t => t.sentimentData?.entrysentiment || 0.5);
        const returns = trades.map(t => t.pnl || 0);
        
        return this.calculateCorrelation(sentiments, returns);
    }

    private calculateCorrelation(x: number[], y: number[]): number {
        const n = x.length;
        if (n === 0) return 0;
        
        const sumX = x.reduce((a, b) => a + b, 0);
        const sumY = y.reduce((a, b) => a + b, 0);
        const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
        const sumXX = x.reduce((sum, xi) => sum + xi * xi, 0);
        const sumYY = y.reduce((sum, yi) => sum + yi * yi, 0);
        
        const numerator = n * sumXY - sumX * sumY;
        const denominator = Math.sqrt((n * sumXX - sumX * sumX) * (n * sumYY - sumY * sumY));
        
        return denominator === 0 ? 0 : numerator / denominator;
    }
}
