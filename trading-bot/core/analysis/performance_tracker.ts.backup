/**
 * ðŸš€ PERFORMANCE TRACKER
 * Comprehensive performance monitoring and metrics calculation
 */

import { EventEmitter } from 'events';
import { Logger } from '../utils/logger';
import { Signal } from '../types';

export interface TradingDecision {
    type: 'buy' | 'sell' | 'hold';
    size: number;
    price: number;
    timestamp: number;
    confidence: number;
    symbol?: string;
    action?: 'BUY' | 'SELL';
    quantity?: number;
    strategy?: string;
}

export interface PerformanceMetrics {
    totalReturn: number;
    annualizedReturn: number;
    volatility: number;
    sharpeRatio: number;
    maxDrawdown: number;
    winRate: number;
    profitFactor: number;
    totalTrades: number;
    avgTradeDuration: number;
    averageWin: number;
    averageLoss: number;
    calmarRatio: number;
    sortinoRatio: number;
    winningTrades: number;
    losingTrades: number;
    largestWin: number;
    largestLoss: number;
    averageHoldingPeriod: number;
    lastUpdated: number;
}

export interface Trade {
    id: string;
    symbol: string;
    side: 'BUY' | 'SELL';
    quantity: number;
    entryPrice: number;
    exitPrice?: number;
    entryTime: Date;
    exitTime?: Date;
    pnl?: number;
    commission: number;
    strategy: string;
    status: 'OPEN' | 'CLOSED';
}

export interface PerformanceWindow {
    startTime: Date;
    endTime: Date;
    metrics: PerformanceMetrics;
    trades: Trade[];
    portfolioValue: number[];
    benchmarkReturn?: number;
}

export class PerformanceTracker extends EventEmitter {
    private logger: Logger;
    private trades: Trade[] = [];
    private portfolioHistory: { timestamp: Date; value: number }[] = [];
    private initialCapital: number;
    private currentCapital: number;
    private openPositions: Map<string, Trade> = new Map();
    private performanceWindows: PerformanceWindow[] = [];
    private riskFreeRate: number = 0.02; // 2% annual risk-free rate
    
    constructor(initialCapital: number = 100000) {
        super();
        this.logger = new Logger();
        this.initialCapital = initialCapital;
        this.currentCapital = initialCapital;
        
        this.logger.info(`Performance tracker initialized with capital: $${initialCapital}`);
    }
    
    /**
     * Record a new trade
     */
    recordTrade(decision: TradingDecision, price?: number): string {
        const tradeId = `trade_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        const trade: Trade = {
            id: tradeId,
            symbol: decision.symbol || 'UNKNOWN',
            side: decision.action as 'BUY' | 'SELL' || 'BUY',
            quantity: decision.quantity || decision.size,
            entryPrice: price || decision.price,
            entryTime: new Date(decision.timestamp),
            commission: this.calculateCommission(decision.quantity || decision.size, price || decision.price),
            strategy: decision.strategy || 'UNKNOWN',
            status: 'OPEN' as const
        };
        
        this.trades.push(trade);
        this.openPositions.set(tradeId, trade);
        
        this.logger.debug(`Trade recorded: ${trade.side} ${trade.quantity} ${trade.symbol} at $${trade.entryPrice}`);
        this.emit('tradeOpened', trade);
        
        return tradeId;
    }
    
    /**
     * Close a trade
     */
    closeTrade(tradeId: string, exitPrice: number, exitTime?: Date): boolean {
        const trade = this.openPositions.get(tradeId);
        if (!trade) {
            this.logger.warn(`Attempt to close non-existent trade: ${tradeId}`);
            return false;
        }
        
        trade.exitPrice = exitPrice;
        trade.exitTime = exitTime || new Date();
        trade.status = 'CLOSED';
        
        // Calculate P&L
        const priceChange = trade.side === 'BUY' 
            ? exitPrice - trade.entryPrice 
            : trade.entryPrice - exitPrice;
        
        trade.pnl = (priceChange * trade.quantity) - trade.commission;
        
        this.currentCapital += trade.pnl;
        this.openPositions.delete(tradeId);
        
        this.logger.debug(`Trade closed: ${tradeId}, P&L: $${trade.pnl?.toFixed(2)}`);
        this.emit('tradeClosed', trade);
        
        return true;
    }
    
    /**
     * Update portfolio value
     */
    updatePortfolioValue(value: number): void {
        this.portfolioHistory.push({
            timestamp: new Date(),
            value: value
        });
        
        this.currentCapital = value;
        this.emit('portfolioUpdated', { value, timestamp: new Date() });
    }
    
    /**
     * Calculate current performance metrics
     */
    calculateMetrics(windowDays?: number): PerformanceMetrics {
        const relevantTrades = windowDays 
            ? this.getTradesInWindow(windowDays)
            : this.trades.filter(t => t.status === 'CLOSED');
        
        if (relevantTrades.length === 0) {
            return this.getEmptyMetrics();
        }
        
        const returns = this.calculateReturns(relevantTrades);
        const totalReturn = this.calculateTotalReturn();
        const sharpeRatio = this.calculateSharpeRatio(returns);
        const maxDrawdown = this.calculateMaxDrawdown();
        const winRate = this.calculateWinRate(relevantTrades);
        
        const winningTrades = relevantTrades.filter(t => (t.pnl || 0) > 0);
        const losingTrades = relevantTrades.filter(t => (t.pnl || 0) < 0);
        
        const averageWin = winningTrades.length > 0 
            ? winningTrades.reduce((sum, t) => sum + (t.pnl || 0), 0) / winningTrades.length
            : 0;
        
        const averageLoss = losingTrades.length > 0
            ? Math.abs(losingTrades.reduce((sum, t) => sum + (t.pnl || 0), 0) / losingTrades.length)
            : 0;
        
        const profitFactor = averageLoss > 0 ? averageWin / averageLoss : 0;
        const volatility = this.calculateVolatility(returns);
        const calmarRatio = maxDrawdown > 0 ? totalReturn / maxDrawdown : 0;
        const sortinoRatio = this.calculateSortinoRatio(returns);
        
        return {
            totalReturn,
            sharpeRatio,
            maxDrawdown,
            winRate,
            averageWin,
            averageLoss,
            profitFactor,
            calmarRatio,
            sortinoRatio,
            totalTrades: relevantTrades.length,
            winningTrades: winningTrades.length,
            losingTrades: losingTrades.length,
            largestWin: winningTrades.length > 0 ? Math.max(...winningTrades.map(t => t.pnl || 0)) : 0,
            largestLoss: losingTrades.length > 0 ? Math.min(...losingTrades.map(t => t.pnl || 0)) : 0,
            averageHoldingPeriod: this.calculateAverageHoldingPeriod(relevantTrades),
            volatility,
            annualizedReturn: returns.length > 0 ? (returns.reduce((sum, r) => sum + r, 0) / returns.length) * 252 : 0,
            avgTradeDuration: this.calculateAverageHoldingPeriod(relevantTrades),
            lastUpdated: Date.now()
        };
    }
    
    /**
     * Get performance trend analysis
     */
    getPerformanceTrend(periods: number = 10): { 
        improving: boolean; 
        trend: number; 
        confidence: number;
        recentMetrics: PerformanceMetrics;
    } {
        if (this.trades.length < periods) {
            return { 
                improving: false, 
                trend: 0, 
                confidence: 0,
                recentMetrics: this.getEmptyMetrics()
            };
        }
        
        const recentTrades = this.trades.slice(-periods);
        const recentMetrics = this.calculateMetricsForTrades(recentTrades);
        
        // Calculate trend based on recent performance windows
        const windowSize = Math.max(5, Math.floor(periods / 3));
        const windows = [];
        
        for (let i = windowSize; i <= periods; i += windowSize) {
            const windowTrades = recentTrades.slice(-i, -i + windowSize);
            if (windowTrades.length > 0) {
                windows.push(this.calculateMetricsForTrades(windowTrades));
            }
        }
        
        if (windows.length < 2) {
            return { 
                improving: false, 
                trend: 0, 
                confidence: 0.5,
                recentMetrics
            };
        }
        
        // Calculate trend slope based on Sharpe ratio improvement
        const trendPoints = windows.map((w, i) => ({ x: i, y: w.sharpeRatio }));
        const trend = this.calculateLinearTrend(trendPoints);
        const improving = trend > 0;
        const confidence = Math.min(1, Math.abs(trend) * windows.length / 10);
        
        return { improving, trend, confidence, recentMetrics };
    }
    
    /**
     * Check if optimization is needed based on performance
     */
    shouldOptimize(thresholds: {
        sharpeRatio?: number;
        maxDrawdown?: number;
        winRate?: number;
        lookbackPeriods?: number;
    } = {}): { needed: boolean; reasons: string[]; metrics: PerformanceMetrics } {
        const {
            sharpeRatio: minSharpe = 1.0,
            maxDrawdown: maxDD = 0.15,
            winRate: minWinRate = 0.45,
            lookbackPeriods = 50
        } = thresholds;
        
        const metrics = this.calculateMetrics(lookbackPeriods);
        const reasons: string[] = [];
        
        if (metrics.sharpeRatio < minSharpe) {
            reasons.push(`Sharpe ratio (${metrics.sharpeRatio.toFixed(2)}) below threshold (${minSharpe})`);
        }
        
        if (metrics.maxDrawdown > maxDD) {
            reasons.push(`Max drawdown (${(metrics.maxDrawdown * 100).toFixed(1)}%) exceeds threshold (${(maxDD * 100).toFixed(1)}%)`);
        }
        
        if (metrics.winRate < minWinRate) {
            reasons.push(`Win rate (${(metrics.winRate * 100).toFixed(1)}%) below threshold (${(minWinRate * 100).toFixed(1)}%)`);
        }
        
        const needed = reasons.length > 0;
        
        if (needed) {
            this.logger.info(`Optimization recommended: ${reasons.join(', ')}`);
        }
        
        return { needed, reasons, metrics };
    }
    
    /**
     * Get comprehensive performance report
     */
    getPerformanceReport(): {
        summary: PerformanceMetrics;
        trend: any;
        optimization: any;
        trades: {
            total: number;
            open: number;
            closed: number;
            recent: Trade[];
        };
        portfolio: {
            current: number;
            initial: number;
            change: number;
            changePercent: number;
        };
    } {
        const summary = this.calculateMetrics();
        const trend = this.getPerformanceTrend();
        const optimization = this.shouldOptimize();
        
        return {
            summary,
            trend,
            optimization,
            trades: {
                total: this.trades.length,
                open: this.openPositions.size,
                closed: this.trades.filter(t => t.status === 'CLOSED').length,
                recent: this.trades.slice(-10)
            },
            portfolio: {
                current: this.currentCapital,
                initial: this.initialCapital,
                change: this.currentCapital - this.initialCapital,
                changePercent: (this.currentCapital - this.initialCapital) / this.initialCapital
            }
        };
    }
    
    // Private helper methods
    private calculateCommission(quantity: number, price: number): number {
        return quantity * price * 0.001; // 0.1% commission
    }
    
    private getTradesInWindow(days: number): Trade[] {
        const cutoffDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);
        return this.trades.filter(t => 
            t.status === 'CLOSED' && 
            t.exitTime && 
            t.exitTime >= cutoffDate
        );
    }
    
    private calculateReturns(trades: Trade[]): number[] {
        return trades
            .filter(t => t.pnl !== undefined)
            .map(t => (t.pnl || 0) / this.initialCapital);
    }
    
    private calculateTotalReturn(): number {
        return (this.currentCapital - this.initialCapital) / this.initialCapital;
    }
    
    private calculateSharpeRatio(returns: number[]): number {
        if (returns.length === 0) return 0;
        
        const avgReturn = returns.reduce((sum, r) => sum + r, 0) / returns.length;
        const variance = returns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / returns.length;
        const stdDev = Math.sqrt(variance);
        
        if (stdDev === 0) return 0;
        
        // Annualized Sharpe ratio
        const annualizedReturn = avgReturn * 252; // 252 trading days
        const annualizedStdDev = stdDev * Math.sqrt(252);
        
        return (annualizedReturn - this.riskFreeRate) / annualizedStdDev;
    }
    
    private calculateMaxDrawdown(): number {
        if (this.portfolioHistory.length < 2) return 0;
        
        let maxDrawdown = 0;
        let peak = this.portfolioHistory[0].value;
        
        for (const point of this.portfolioHistory) {
            if (point.value > peak) {
                peak = point.value;
            }
            
            const drawdown = (peak - point.value) / peak;
            maxDrawdown = Math.max(maxDrawdown, drawdown);
        }
        
        return maxDrawdown;
    }
    
    private calculateWinRate(trades: Trade[]): number {
        const closedTrades = trades.filter(t => t.status === 'CLOSED' && t.pnl !== undefined);
        if (closedTrades.length === 0) return 0;
        
        const winningTrades = closedTrades.filter(t => (t.pnl || 0) > 0);
        return winningTrades.length / closedTrades.length;
    }
    
    private calculateVolatility(returns: number[]): number {
        if (returns.length === 0) return 0;
        
        const avgReturn = returns.reduce((sum, r) => sum + r, 0) / returns.length;
        const variance = returns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / returns.length;
        
        return Math.sqrt(variance * 252); // Annualized volatility
    }
    
    private calculateSortinoRatio(returns: number[]): number {
        if (returns.length === 0) return 0;
        
        const avgReturn = returns.reduce((sum, r) => sum + r, 0) / returns.length;
        const negativeReturns = returns.filter(r => r < 0);
        
        if (negativeReturns.length === 0) return Infinity;
        
        const downwardDeviation = Math.sqrt(
            negativeReturns.reduce((sum, r) => sum + Math.pow(r, 2), 0) / negativeReturns.length
        );
        
        const annualizedReturn = avgReturn * 252;
        const annualizedDownwardDev = downwardDeviation * Math.sqrt(252);
        
        return (annualizedReturn - this.riskFreeRate) / annualizedDownwardDev;
    }
    
    private calculateAverageHoldingPeriod(trades: Trade[]): number {
        const closedTrades = trades.filter(t => t.status === 'CLOSED' && t.exitTime);
        if (closedTrades.length === 0) return 0;
        
        const totalHours = closedTrades.reduce((sum, t) => {
            const holdingTime = (t.exitTime!.getTime() - t.entryTime.getTime()) / (1000 * 60 * 60);
            return sum + holdingTime;
        }, 0);
        
        return totalHours / closedTrades.length;
    }
    
    private calculateMetricsForTrades(trades: Trade[]): PerformanceMetrics {
        const closedTrades = trades.filter(t => t.status === 'CLOSED');
        if (closedTrades.length === 0) return this.getEmptyMetrics();
        
        const returns = this.calculateReturns(closedTrades);
        const winningTrades = closedTrades.filter(t => (t.pnl || 0) > 0);
        const losingTrades = closedTrades.filter(t => (t.pnl || 0) < 0);
        
        return {
            totalReturn: returns.reduce((sum, r) => sum + r, 0),
            sharpeRatio: this.calculateSharpeRatio(returns),
            maxDrawdown: 0, // Simplified for individual trade windows
            winRate: winningTrades.length / closedTrades.length,
            averageWin: winningTrades.length > 0 
                ? winningTrades.reduce((sum, t) => sum + (t.pnl || 0), 0) / winningTrades.length
                : 0,
            averageLoss: losingTrades.length > 0
                ? Math.abs(losingTrades.reduce((sum, t) => sum + (t.pnl || 0), 0) / losingTrades.length)
                : 0,
            profitFactor: 0,
            calmarRatio: 0,
            sortinoRatio: this.calculateSortinoRatio(returns),
            totalTrades: closedTrades.length,
            winningTrades: winningTrades.length,
            losingTrades: losingTrades.length,
            largestWin: winningTrades.length > 0 ? Math.max(...winningTrades.map(t => t.pnl || 0)) : 0,
            largestLoss: losingTrades.length > 0 ? Math.min(...losingTrades.map(t => t.pnl || 0)) : 0,
            averageHoldingPeriod: this.calculateAverageHoldingPeriod(closedTrades),
            volatility: this.calculateVolatility(returns),
            annualizedReturn: returns.length > 0 ? (returns.reduce((sum, r) => sum + r, 0) / returns.length) * 252 : 0,
            avgTradeDuration: this.calculateAverageHoldingPeriod(closedTrades),
            lastUpdated: Date.now()
        };
    }
    
    private calculateLinearTrend(points: { x: number; y: number }[]): number {
        const n = points.length;
        if (n < 2) return 0;
        
        const sumX = points.reduce((sum, p) => sum + p.x, 0);
        const sumY = points.reduce((sum, p) => sum + p.y, 0);
        const sumXY = points.reduce((sum, p) => sum + p.x * p.y, 0);
        const sumXX = points.reduce((sum, p) => sum + p.x * p.x, 0);
        
        const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
        return slope;
    }
    
    private getEmptyMetrics(): PerformanceMetrics {
        return {
            totalReturn: 0,
            sharpeRatio: 0,
            maxDrawdown: 0,
            winRate: 0,
            averageWin: 0,
            averageLoss: 0,
            profitFactor: 0,
            calmarRatio: 0,
            sortinoRatio: 0,
            totalTrades: 0,
            winningTrades: 0,
            losingTrades: 0,
            largestWin: 0,
            largestLoss: 0,
            averageHoldingPeriod: 0,
            volatility: 0,
            annualizedReturn: 0,
            avgTradeDuration: 0,
            lastUpdated: Date.now()
}
