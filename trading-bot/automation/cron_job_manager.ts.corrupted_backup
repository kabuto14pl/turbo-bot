/**
 * üïê CRON JOB MANAGER
 * ZarzƒÖdza wszystkimi zaplanowanymi zadaniami w systemie trading bot
 * Obs≈Çuguje daily reoptimization, weekly retrain, performance m  /**
   * üî• Trigger a job manually (for testing)
   */
  public async triggerJob(jobId: string): Promise<void> {
    const job = this.jobs.get(jobId);
    if (!job) {
      throw new Error(`Job not found: ${jobId}`);
    }
    await this.executeJob(job);
  } */
import { EventEmitter } from 'events';
import { Logger } from '../core/utils/logger';

export interface CronJob {
  id: string;
  name: string;
  schedule: string;  // Cron expression (e.g., "0 2 * * 0" = Sunday 2AM)
  handler: () => Promise<void>;
  enabled: boolean;
  lastRun?: Date;
  nextRun?: Date;
  status: 'idle' | 'running' | 'error' | 'disabled';
  errorCount: number;
  maxRetries: number;
  timeout: number;  // milliseconds
  metadata?: Record<string, any>;
}

export interface CronJobConfig {
  timezone?: string;
  enableLogging?: boolean;
  maxConcurrentJobs?: number;
  defaultTimeout?: number;
  defaultRetries?: number;
}

export interface CronJobStats {
  totalJobs: number;
  activeJobs: number;
  runningJobs: number;
  failedJobs: number;
  successfulRuns: number;
  failedRuns: number;
  averageExecutionTime: number;
  uptime: number;
}

/**
 * üìÖ ADVANCED CRON JOB MANAGER
 * Professional-grade task scheduler for trading bot automation
 */
export class CronJobManager extends EventEmitter {
  private logger: Logger;
  private jobs: Map<string, CronJob> = new Map();
  private runningJobs: Set<string> = new Set();
  private schedulerInterval?: NodeJS.Timeout;
  private startTime: Date;
  private stats: CronJobStats;
  private config: CronJobConfig;

  constructor(config: CronJobConfig = {}) {
    super();
    
    this.config = {
      timezone: 'UTC',
      enableLogging: true,
      maxConcurrentJobs: 5,
      defaultTimeout: 300000, // 5 minutes
      ...config
    };

    this.logger = new Logger();
    this.startTime = new Date();
    
    this.stats = {
      totalJobs: 0,
      activeJobs: 0,
      runningJobs: 0,
      failedJobs: 0,
      successfulRuns: 0,
      failedRuns: 0,
      averageExecutionTime: 0,
      uptime: 0
    };

    this.logger.info('üïê Cron Job Manager initialized');
  }

  /**
   * Dodaje zadanie cron na podstawie id, harmonogramu i callbacka
   */
  public addJob(id: string, cron: string, callback: () => Promise<void>): void {
    const job: Omit<CronJob, 'status' | 'errorCount' | 'nextRun'> = {
      id,
      name: id,
      schedule: cron,
      handler: callback,
      enabled: true,
      maxRetries: this.config.defaultRetries ?? 1,
      timeout: this.config.defaultTimeout ?? 300000,
      metadata: {}
    };
    this.addJobObject(job);
  }

  /**
   * ‚ûï Add a new cron job
   */
  addJobObject(job: Omit<CronJob, 'status' | 'errorCount' | 'nextRun'>): void {
    const cronJob: CronJob = {
      ...job,
      status: job.enabled ? 'idle' : 'disabled',
      errorCount: 0,
      maxRetries: job.maxRetries || this.config.defaultRetries!,
      timeout: job.timeout || this.config.defaultTimeout!,
      nextRun: job.enabled ? this.calculateNextRun(job.schedule) : undefined
    };

    this.jobs.set(job.id, cronJob);
    this.stats.totalJobs = this.jobs.size;
    this.stats.activeJobs = Array.from(this.jobs.values()).filter(j => j.enabled).length;

    this.logger.info(`üìã Added job: ${job.name} (${job.id})`);
    this.logger.info(`üìÖ Next run: ${cronJob.nextRun?.toISOString() || 'disabled'}`);
    
    this.emit('jobAdded', cronJob);
  }

  /**
   * ‚ñ∂Ô∏è Start the cron scheduler
   */
  start(): void {
    if (this.schedulerInterval) {
      this.logger.warn('Cron scheduler is already running');
      return;
    }

    this.logger.info('üöÄ Starting Cron Job Manager...');
    
    // Check for jobs to run every minute
    this.schedulerInterval = setInterval(() => {
      this.checkAndRunJobs().catch(error => {
        this.logger.error('Error in scheduler loop:', error);
      });
    }, 60000); // Check every minute

    this.emit('started');
    this.logger.info('‚úÖ Cron Job Manager started successfully');
  }

  /**
   * ‚èπÔ∏è Stop the cron scheduler
   */
  stop(): void {
    if (this.schedulerInterval) {
      clearInterval(this.schedulerInterval);
      this.schedulerInterval = undefined;
    }

    // Wait for running jobs to complete (with timeout)
    this.waitForRunningJobs().then(() => {
      this.logger.info('üõë Cron Job Manager stopped');
      this.emit('stopped');
    });
  }

  /**
   * ÔøΩ Trigger a job manually (for testing)
   */
  public async triggerJob(jobId: string): Promise<void> {
    const job = this.jobs.find(j => j.id === jobId);
    if (!job) {
      throw new Error(`Job not found: ${jobId}`);
    }
    await this.executeJob(job);
  }

  /**
   * ÔøΩüîç Check and run jobs that are due
   */
  private async checkAndRunJobs(): Promise<void> {
    const now = new Date();
    this.updateStats();

    for (const [jobId, job] of this.jobs) {
      if (this.shouldRunJob(job, now)) {
        await this.executeJob(job);
      }
    }
  }

  /**
   * üéØ Determine if a job should run
   */
  private shouldRunJob(job: CronJob, now: Date): boolean {
    if (!job.enabled || job.status === 'running') {
      return false;
    }

    if (this.runningJobs.size >= this.config.maxConcurrentJobs!) {
      this.logger.warn(`‚ö†Ô∏è Max concurrent jobs (${this.config.maxConcurrentJobs}) reached`);
      return false;
    }

    if (!job.nextRun) {
      return false;
    }

    return now >= job.nextRun;
  }

  /**
   * üöÄ Execute a job
   */
  private async executeJob(job: CronJob): Promise<void> {
    const startTime = Date.now();
    
    try {
      this.logger.info(`üîÑ Starting job: ${job.name} (${job.id})`);
      
      job.status = 'running';
      job.lastRun = new Date();
      this.runningJobs.add(job.id);
      this.stats.runningJobs = this.runningJobs.size;

      this.emit('jobStarted', job);

      // Execute with timeout
      await this.executeWithTimeout(job);

      // Job completed successfully
      job.status = 'idle';
      job.errorCount = 0;
      job.nextRun = this.calculateNextRun(job.schedule);
      
      const executionTime = Date.now() - startTime;
      this.stats.successfulRuns++;
      this.updateAverageExecutionTime(executionTime);

      this.logger.info(`‚úÖ Job completed: ${job.name} (${executionTime}ms)`);
      this.emit('jobCompleted', job, executionTime);

    } catch (error) {
      this.handleJobError(job, error, startTime);
    } finally {
      this.runningJobs.delete(job.id);
      this.stats.runningJobs = this.runningJobs.size;
    }
  }

  /**
   * ‚ö° Execute job with timeout
   */
  private async executeWithTimeout(job: CronJob): Promise<void> {
    return new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        reject(new Error(`Job timeout after ${job.timeout}ms`));
      }, job.timeout);

      job.handler()
        .then(() => {
          clearTimeout(timeoutId);
          resolve();
        })
        .catch(error => {
          clearTimeout(timeoutId);
          reject(error);
        });
    });
  }

  /**
   * ‚ùå Handle job execution error
   */
  private handleJobError(job: CronJob, error: any, startTime: number): void {
    const executionTime = Date.now() - startTime;
    job.errorCount++;
    this.stats.failedRuns++;

    this.logger.error(`‚ùå Job failed: ${job.name} (attempt ${job.errorCount}/${job.maxRetries})`, error);

    if (job.errorCount >= job.maxRetries) {
      job.status = 'error';
      this.stats.failedJobs++;
      this.logger.error(`üíÄ Job permanently failed: ${job.name}`);
      this.emit('jobFailed', job, error);
    } else {
      job.status = 'idle';
      job.nextRun = this.calculateNextRun(job.schedule, 5); // Retry in 5 minutes
      this.logger.warn(`üîÑ Job will retry: ${job.name} at ${job.nextRun?.toISOString()}`);
      this.emit('jobRetry', job, error);
    }
  }

  /**
   * üìä Calculate next run time based on cron expression
   */
  private calculateNextRun(schedule: string, offsetMinutes: number = 0): Date {
    // Simplified cron parser for common patterns
    const now = new Date();
    const nextRun = new Date(now.getTime() + offsetMinutes * 60000);

    // Parse basic cron expressions
    const parts = schedule.split(' ');
    if (parts.length !== 5) {
      throw new Error(`Invalid cron expression: ${schedule}`);
    }

    const [minute, hour, dayOfMonth, month, dayOfWeek] = parts;

    // Handle some common patterns
    if (schedule === '0 2 * * 0') { // Sunday 2AM
      const next = new Date(nextRun);
      next.setHours(2, 0, 0, 0);
      next.setDate(next.getDate() + (7 - next.getDay()) % 7);
      if (next <= now) next.setDate(next.getDate() + 7);
      return next;
    }

    if (schedule === '0 3 * * *') { // Daily 3AM
      const next = new Date(nextRun);
      next.setHours(3, 0, 0, 0);
      if (next <= now) next.setDate(next.getDate() + 1);
      return next;
    }

    if (schedule === '0 * * * *') { // Every hour
      const next = new Date(nextRun);
      next.setMinutes(0, 0, 0);
      next.setHours(next.getHours() + 1);
      return next;
    }

    // Default: next hour (fallback)
    nextRun.setHours(nextRun.getHours() + 1, 0, 0, 0);
    return nextRun;
  }

  /**
   * ‚è≥ Wait for all running jobs to complete
   */
  private async waitForRunningJobs(timeout: number = 30000): Promise<void> {
    const startTime = Date.now();
    
    while (this.runningJobs.size > 0 && (Date.now() - startTime) < timeout) {
      await new Promise(resolve => setTimeout(resolve, 1000));
    }

    if (this.runningJobs.size > 0) {
      this.logger.warn(`‚ö†Ô∏è ${this.runningJobs.size} jobs still running after timeout`);
    }
  }

  /**
   * üìä Update statistics
   */
  private updateStats(): void {
    this.stats.uptime = Date.now() - this.startTime.getTime();
    this.stats.activeJobs = Array.from(this.jobs.values()).filter(j => j.enabled).length;
    this.stats.runningJobs = this.runningJobs.size;
  }

  /**
   * üìà Update average execution time
   */
  private updateAverageExecutionTime(executionTime: number): void {
    const totalRuns = this.stats.successfulRuns;
    this.stats.averageExecutionTime = 
      (this.stats.averageExecutionTime * (totalRuns - 1) + executionTime) / totalRuns;
  }

  /**
   * üìã Get job by ID
   */
  getJob(jobId: string): CronJob | undefined {
    return this.jobs.get(jobId);
  }

  /**
   * üìù List all jobs
   */
  listJobs(): CronJob[] {
    return Array.from(this.jobs.values());
  }

  /**
   * üîÑ Enable/disable job
   */
  setJobEnabled(jobId: string, enabled: boolean): void {
    const job = this.jobs.get(jobId);
    if (!job) {
      throw new Error(`Job not found: ${jobId}`);
    }

    job.enabled = enabled;
    job.status = enabled ? 'idle' : 'disabled';
    job.nextRun = enabled ? this.calculateNextRun(job.schedule) : undefined;

    this.logger.info(`üîÑ Job ${enabled ? 'enabled' : 'disabled'}: ${job.name}`);
    this.emit('jobToggled', job);
  }

  /**
   * üóëÔ∏è Remove job
   */
  removeJob(jobId: string): void {
    const job = this.jobs.get(jobId);
    if (!job) {
      throw new Error(`Job not found: ${jobId}`);
    }

    if (job.status === 'running') {
      throw new Error(`Cannot remove running job: ${jobId}`);
    }

    this.jobs.delete(jobId);
    this.stats.totalJobs = this.jobs.size;
    
    this.logger.info(`üóëÔ∏è Job removed: ${job.name}`);
    this.emit('jobRemoved', job);
  }

  /**
   * üìä Get statistics
   */
  getStats(): CronJobStats {
    this.updateStats();
    return { ...this.stats };
  }

  /**
   * üè• Health check
   */
  getHealth(): { status: 'healthy' | 'warning' | 'critical', details: any } {
    const stats = this.getStats();
    
    if (stats.failedJobs > stats.totalJobs * 0.5) {
      return {
        status: 'critical',
        details: { message: 'More than 50% of jobs have failed', stats }
      };
    }

    if (stats.runningJobs > this.config.maxConcurrentJobs! * 0.8) {
      return {
        status: 'warning',
        details: { message: 'High job concurrency', stats }
      };
    }

    return {
      status: 'healthy',
      details: { message: 'All systems operational', stats }
    };
  }
}

export default CronJobManager;
