@startuml TradingSystemArchitecture

package "üîí Security Layer" <<Frame>> {
    component "SecureConfigManager" as SCM {
        + initialize(): Promise<void>
        + getConfig(): ProductionConfig
        + validateEnvironment(): void
        + encryptData(data: string): string
        --
        - encryptionKey: Buffer
        - config: ProductionConfig
        - gdprCompliance: GDPRMode
    }
    
    component "GDPRCompliantLogger" as GCL {
        + logTradeEvent(event: TradeEvent): Promise<void>
        + anonymizeData(data: PersonalData): string
        + enforceRetention(): Promise<void>
        --
        - encryptionKey: Buffer
        - retentionDays: number
        - complianceMode: 'strict' | 'standard'
    }
}

package "üìä Strategy Engine" <<Frame>> {
    interface IStrategy {
        + execute(data: MarketData): Promise<StrategyResult>
        + getConfig(): any
        + updateConfig(config: any): void
    }
    
    component "PairsTradingStrategy" as PTS {
        + execute(data: MarketData): Promise<StrategyResult>
        + testCointegration(prices1, prices2): Promise<CointegrationResult>
        + calculateCorrelation(x, y): number
        + calculateOptimalHedgeRatio(prices1, prices2): number
        --
        - lookbackPeriod: 252
        - entryThreshold: 2.0
        - correlationThreshold: 0.7
        - cointegrationResults: Map<string, CointegrationResult>
    }
    
    component "EnhancedRSITurboStrategy" as ERTS {
        + run(state: BotState): Promise<StrategySignal[]>
        + validateState(state: BotState): boolean
        --
        - previousRsi: number
        - overbought: 66
        - oversold: 29
        - ultraOptimized: true
    }
    
    component "GridTradingStrategy" as GTS {
        + execute(data: MarketData): Promise<StrategyResult>
        + initializeGrid(centerPrice, gridCount): void
        --
        - gridLevels: GridLevel[]
        - gridSpacing: 0.01
        - baseQuantity: 0.1
    }
}

package "üõ°Ô∏è Risk Management" <<Frame>> {
    component "AdvancedRiskManager" as ARM {
        + validatePortfolio(positions, equity): RiskStatusResult
        + validateTrade(position, existing, equity): TradeValidation
        + calculateVaR(portfolio, confidence): number
        --
        - maxTotalExposure: 0.3
        - maxDrawdown: 0.15
        - maxCorrelationRisk: 0.8
    }
    
    component "MLRiskModelEngine" as MLRME {
        + assessRealTimeRisk(data): Promise<RiskMetrics>
        + predictDrawdown(portfolio): Promise<DrawdownPrediction>
        + generateRiskAlerts(metrics): Promise<void>
        --
        - varModel: VaRModel
        - cvarModel: CVaRModel
        - neuralRiskModel: NeuralNetworkRiskModel
    }
    
    component "KellyCalculator" as KC {
        + calculateOptimalSize(probability, payoff): number
        + adaptiveKelly(winRate, avgWin, avgLoss): number
        --
        - maxKellyFraction: 0.25
        - conservativeFactor: 0.5
    }
}

package "üì° Data Processing" <<Frame>> {
    component "DuckDBAdapter" as DDB {
        + saveSeries(tableName, data): Promise<void>
        + loadSeries(tableName, where?): Promise<any[]>
        + runAnalytics(query): Promise<QueryResult>
        --
        - db: Database
        - dbPath: string
    }
    
    component "BinanceWebSocketClient" as BWS {
        + connect(): Promise<void>
        + subscribe(symbol): void
        + onMarketData(callback): void
        --
        - connections: Map<string, WebSocket>
        - reconnectAttempts: number
        - isConnected: boolean
    }
    
    component "KafkaEventBus" as KEB {
        + publish(topic, message): Promise<void>
        + subscribe(topic, handler): void
        + createTopic(config): Promise<void>
        --
        - topics: Map<string, Topic>
        - consumers: Consumer[]
        - producers: Producer[]
    }
}

package "üß† ML Integration" <<Frame>> {
    component "RayOptunaOptimizer" as ROO {
        + optimizeParameters(strategy, data): Promise<OptimizationResult>
        + distributedSearch(searchSpace): Promise<BestParams>
        --
        - rayAvailable: boolean
        - optunaStudy: Study
        - nTrials: 1000
    }
    
    component "TensorFlowMLEngine" as TFML {
        + predictPrice(marketData): Promise<PricePrediction>
        + classifySignal(indicators): Promise<SignalClassification>
        + assessRisk(portfolio): Promise<RiskAssessment>
        --
        - pricePredictor: LSTMModel
        - signalClassifier: CNNModel  
        - riskPredictor: TransformerModel
    }
}

' Relationships
SCM --> GCL : configuration
IStrategy <|-- PTS
IStrategy <|-- ERTS  
IStrategy <|-- GTS

PTS --> ARM : risk validation
ERTS --> ARM : risk validation
GTS --> ARM : risk validation

ARM --> MLRME : ML risk assessment
ARM --> KC : position sizing

BWS --> KEB : market data stream
KEB --> PTS : data feed
KEB --> ERTS : data feed
KEB --> GTS : data feed

PTS --> DDB : store analytics
MLRME --> DDB : risk metrics

ROO --> PTS : parameter optimization
ROO --> ERTS : parameter optimization

TFML --> MLRME : ML predictions
TFML --> ARM : risk signals

SCM --> ARM : security config
GCL --> ARM : audit logging

note top of PTS : **Pairs Trading Details:**\n‚Ä¢ Johansen cointegration test\n‚Ä¢ Pearson correlation (min 0.7)\n‚Ä¢ Z-score mean reversion (¬±2.0)\n‚Ä¢ Optimal hedge ratio (OLS)\n‚Ä¢ Rolling correlation windows

note top of ARM : **Risk Management:**\n‚Ä¢ VaR calculations (95%, 99%)\n‚Ä¢ Kelly criterion position sizing\n‚Ä¢ Real-time drawdown monitoring\n‚Ä¢ Portfolio correlation limits

note top of TFML : **ML Integration:**\n‚Ä¢ TensorFlow 2.15+\n‚Ä¢ LSTM price prediction\n‚Ä¢ CNN signal classification\n‚Ä¢ Transformer risk assessment

@enduml
