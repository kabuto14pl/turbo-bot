/**
 * üöÄ ADVANCED REAL-TIME TRADING SIGNALS SYSTEM
 * 
 * Zaawansowany system sygna≈Ç√≥w tradingowych w czasie rzeczywistym
 * - WebSocket real-time data feeds
 * - ML-powered signal confidence scoring
 * - Multi-asset trading signals
 * - Advanced signal aggregation & filtering
 * - Performance-based signal weighting
 */

import { EventEmitter } from 'events';
import { Logger } from '../trading-bot/infrastructure/logging/logger';
import * as tf from '@tensorflow/tfjs-node';

// ============================================================================
// üéØ INTERFACES & TYPES
// ============================================================================

export interface MarketDataPoint {
    symbol: string;
    timestamp: number;
    price: number;
    volume: number;
    bid: number;
    ask: number;
    spread: number;
    change24h: number;
    volatility: number;
}

export interface TradingSignal {
    id: string;
    symbol: string;
    timestamp: number;
    direction: 'BUY' | 'SELL' | 'HOLD';
    strength: number; // 0-1
    confidence: number; // 0-1
    timeframe: string;
    source: string;
    metadata: {
        indicators: Record<string, number | string>;
        patterns: string[];
        riskLevel: 'LOW' | 'MEDIUM' | 'HIGH';
        expectedReturn: number;
        stopLoss: number;
        takeProfit: number;
    };
}

export interface SignalPerformance {
    signalId: string;
    source: string;
    accuracy: number;
    profitability: number;
    sharpeRatio: number;
    maxDrawdown: number;
    totalTrades: number;
    winRate: number;
    avgReturn: number;
    reliability: number;
}

export interface WebSocketConfig {
    endpoints: {
        binance: string;
        coinbase: string;
        kraken: string;
    };
    symbols: string[];
    reconnectDelay: number;
    maxReconnects: number;
}

// ============================================================================
// ü§ñ ADVANCED REAL-TIME TRADING SIGNALS ENGINE
// ============================================================================

export class AdvancedRealTimeTradingSignals extends EventEmitter {
    private logger: Logger;
    private isActive: boolean = false;
    private marketData: Map<string, MarketDataPoint[]> = new Map();
    private activeSignals: Map<string, TradingSignal> = new Map();
    private signalPerformance: Map<string, SignalPerformance> = new Map();
    
    // ML Models
    private mlModels: {
        pricePredictor?: tf.LayersModel;
        patternDetector?: tf.LayersModel;
        volatilityPredictor?: tf.LayersModel;
        sentimentAnalyzer?: tf.LayersModel;
    } = {};
    
    // WebSocket connections
    private wsConnections: Map<string, WebSocket> = new Map();
    private wsConfig: WebSocketConfig;
    
    // Signal generators
    private signalGenerators: Map<string, Function> = new Map();
    private signalAggregator: SignalAggregator;
    
    // Performance tracking
    private performanceTracker: PerformanceTracker;
    
    constructor(config: Partial<WebSocketConfig> = {}) {
        super();
        this.logger = new Logger('AdvancedRealTimeTradingSignals');
        
        this.wsConfig = {
            endpoints: {
                binance: 'wss://stream.binance.com:9443/ws/',
                coinbase: 'wss://ws-feed.pro.coinbase.com',
                kraken: 'wss://ws.kraken.com'
            },
            symbols: ['BTCUSDT', 'ETHUSDT', 'ADAUSDT', 'SOLUSDT'],
            reconnectDelay: 5000,
            maxReconnects: 10,
            ...config
        };
        
        this.signalAggregator = new SignalAggregator();
        this.performanceTracker = new PerformanceTracker();
        
        this.initializeSignalGenerators();
    }
    
    // ========================================================================
    // üöÄ MAIN CONTROL METHODS
    // ========================================================================
    
    async start(): Promise<void> {
        if (this.isActive) {
            this.logger.warn('üîÑ Real-time signals already active');
            return;
        }
        
        try {
            this.logger.info('üöÄ Starting Advanced Real-Time Trading Signals...');
            
            // Load ML models
            await this.loadMLModels();
            
            // Initialize WebSocket connections
            await this.initializeWebSockets();
            
            // Start signal processing
            this.startSignalProcessing();
            
            this.isActive = true;
            this.logger.info('‚úÖ Real-time trading signals system activated!');
            
            this.emit('started');
            
        } catch (error) {
            this.logger.error('‚ùå Failed to start real-time signals:', error);
            throw error;
        }
    }
    
    async stop(): Promise<void> {
        if (!this.isActive) return;
        
        this.logger.info('üõë Stopping real-time signals...');
        
        // Close WebSocket connections
        for (const [exchange, ws] of this.wsConnections) {
            ws.close();
            this.logger.info(`üì° Closed ${exchange} WebSocket connection`);
        }
        
        this.isActive = false;
        this.logger.info('‚úÖ Real-time signals stopped');
        
        this.emit('stopped');
    }
    
    // ========================================================================
    // ü§ñ ML MODELS LOADING
    // ========================================================================
    
    private async loadMLModels(): Promise<void> {
        try {
            this.logger.info('üß† Loading ML models for signal generation...');
            
            // Price prediction model (LSTM)
            this.mlModels.pricePredictor = await this.createPricePredictionModel();
            this.logger.info('‚úÖ Price predictor model loaded');
            
            // Pattern detection model (CNN)
            this.mlModels.patternDetector = await this.createPatternDetectionModel();
            this.logger.info('‚úÖ Pattern detector model loaded');
            
            // Volatility prediction model
            this.mlModels.volatilityPredictor = await this.createVolatilityModel();
            this.logger.info('‚úÖ Volatility predictor model loaded');
            
            // Sentiment analysis model
            this.mlModels.sentimentAnalyzer = await this.createSentimentModel();
            this.logger.info('‚úÖ Sentiment analyzer model loaded');
            
            this.logger.info('üéØ All ML models loaded successfully');
            
        } catch (error) {
            this.logger.error('‚ùå Failed to load ML models:', error);
            throw error;
        }
    }
    
    private async createPricePredictionModel(): Promise<tf.LayersModel> {
        const model = tf.sequential({
            layers: [
                tf.layers.lstm({
                    units: 128,
                    returnSequences: true,
                    inputShape: [60, 8] // 60 timesteps, 8 features
                }),
                tf.layers.dropout({ rate: 0.2 }),
                tf.layers.lstm({
                    units: 64,
                    returnSequences: false
                }),
                tf.layers.dropout({ rate: 0.2 }),
                tf.layers.dense({ units: 32, activation: 'relu' }),
                tf.layers.dense({ units: 1, activation: 'linear' }) // Price prediction
            ]
        });
        
        model.compile({
            optimizer: tf.train.adam(0.001),
            loss: 'meanSquaredError',
            metrics: ['mae']
        });
        
        return model;
    }
    
    private async createPatternDetectionModel(): Promise<tf.LayersModel> {
        const model = tf.sequential({
            layers: [
                tf.layers.conv1d({
                    filters: 64,
                    kernelSize: 3,
                    activation: 'relu',
                    inputShape: [50, 5] // 50 candles, 5 features (OHLCV)
                }),
                tf.layers.maxPooling1d({ poolSize: 2 }),
                tf.layers.conv1d({
                    filters: 32,
                    kernelSize: 3,
                    activation: 'relu'
                }),
                tf.layers.globalMaxPooling1d(),
                tf.layers.dense({ units: 50, activation: 'relu' }),
                tf.layers.dropout({ rate: 0.3 }),
                tf.layers.dense({ units: 3, activation: 'softmax' }) // BUY, SELL, HOLD
            ]
        });
        
        model.compile({
            optimizer: tf.train.adam(0.001),
            loss: 'categoricalCrossentropy',
            metrics: ['accuracy']
        });
        
        return model;
    }
    
    private async createVolatilityModel(): Promise<tf.LayersModel> {
        const model = tf.sequential({
            layers: [
                tf.layers.dense({ units: 64, activation: 'relu', inputShape: [20] }),
                tf.layers.dropout({ rate: 0.2 }),
                tf.layers.dense({ units: 32, activation: 'relu' }),
                tf.layers.dense({ units: 16, activation: 'relu' }),
                tf.layers.dense({ units: 1, activation: 'sigmoid' }) // Volatility score 0-1
            ]
        });
        
        model.compile({
            optimizer: tf.train.adam(0.001),
            loss: 'binaryCrossentropy',
            metrics: ['accuracy']
        });
        
        return model;
    }
    
    private async createSentimentModel(): Promise<tf.LayersModel> {
        const model = tf.sequential({
            layers: [
                tf.layers.embedding({ inputDim: 10000, outputDim: 128, inputLength: 100 }),
                tf.layers.lstm({ units: 64, dropout: 0.5, recurrentDropout: 0.5 }),
                tf.layers.dense({ units: 32, activation: 'relu' }),
                tf.layers.dropout({ rate: 0.3 }),
                tf.layers.dense({ units: 1, activation: 'sigmoid' }) // Sentiment score 0-1
            ]
        });
        
        model.compile({
            optimizer: tf.train.adam(0.001),
            loss: 'binaryCrossentropy',
            metrics: ['accuracy']
        });
        
        return model;
    }
    
    // ========================================================================
    // üì° WEBSOCKET CONNECTIONS
    // ========================================================================
    
    private async initializeWebSockets(): Promise<void> {
        this.logger.info('üì° Initializing WebSocket connections...');
        
        // Binance WebSocket
        await this.initializeBinanceWS();
        
        // Add other exchanges...
        // await this.initializeCoinbaseWS();
        // await this.initializeKrakenWS();
        
        this.logger.info('‚úÖ All WebSocket connections established');
    }
    
    private async initializeBinanceWS(): Promise<void> {
        const streams = this.wsConfig.symbols.map(symbol => 
            `${symbol.toLowerCase()}@ticker`
        ).join('/');
        
        const wsUrl = `${this.wsConfig.endpoints.binance}${streams}`;
        const ws = new WebSocket(wsUrl);
        
        ws.onopen = () => {
            this.logger.info('üîó Binance WebSocket connected');
            this.wsConnections.set('binance', ws);
        };
        
        ws.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                this.processBinanceData(data);
            } catch (error) {
                this.logger.error('Error processing Binance data:', error);
            }
        };
        
        ws.onerror = (error) => {
            this.logger.error('Binance WebSocket error:', error);
        };
        
        ws.onclose = () => {
            this.logger.warn('üì° Binance WebSocket disconnected');
            // Auto-reconnect logic
            setTimeout(() => this.initializeBinanceWS(), this.wsConfig.reconnectDelay);
        };
    }
    
    private processBinanceData(data: any): void {
        if (data.e === '24hrTicker') {
            const marketData: MarketDataPoint = {
                symbol: data.s,
                timestamp: data.E,
                price: parseFloat(data.c),
                volume: parseFloat(data.v),
                bid: parseFloat(data.b),
                ask: parseFloat(data.a),
                spread: parseFloat(data.a) - parseFloat(data.b),
                change24h: parseFloat(data.P),
                volatility: this.calculateVolatility(data)
            };
            
            this.updateMarketData(marketData);
        }
    }
    
    private calculateVolatility(tickerData: any): number {
        const high = parseFloat(tickerData.h);
        const low = parseFloat(tickerData.l);
        const close = parseFloat(tickerData.c);
        
        return ((high - low) / close) * 100;
    }
    
    private updateMarketData(data: MarketDataPoint): void {
        if (!this.marketData.has(data.symbol)) {
            this.marketData.set(data.symbol, []);
        }
        
        const symbolData = this.marketData.get(data.symbol)!;
        symbolData.push(data);
        
        // Keep only last 1000 data points
        if (symbolData.length > 1000) {
            symbolData.shift();
        }
        
        // Generate signals for this data point
        this.generateSignalsForSymbol(data.symbol, data);
    }
    
    // ========================================================================
    // üéØ SIGNAL GENERATION
    // ========================================================================
    
    private initializeSignalGenerators(): void {
        this.signalGenerators.set('ml_price_prediction', this.generateMLPriceSignal.bind(this));
        this.signalGenerators.set('pattern_detection', this.generatePatternSignal.bind(this));
        this.signalGenerators.set('volatility_breakout', this.generateVolatilitySignal.bind(this));
        this.signalGenerators.set('momentum_signal', this.generateMomentumSignal.bind(this));
        this.signalGenerators.set('mean_reversion', this.generateMeanReversionSignal.bind(this));
    }
    
    private async generateSignalsForSymbol(symbol: string, data: MarketDataPoint): Promise<void> {
        const symbolData = this.marketData.get(symbol);
        if (!symbolData || symbolData.length < 50) return;
        
        const signals: TradingSignal[] = [];
        
        // Generate signals from all generators
        for (const [generatorName, generator] of this.signalGenerators) {
            try {
                const signal = await generator(symbol, symbolData);
                if (signal) {
                    signals.push(signal);
                }
            } catch (error) {
                this.logger.error(`Error in ${generatorName}:`, error);
            }
        }
        
        // Aggregate and filter signals
        const aggregatedSignal = await this.signalAggregator.aggregate(signals, symbol);
        
        if (aggregatedSignal && aggregatedSignal.confidence > 0.7) {
            this.activeSignals.set(aggregatedSignal.id, aggregatedSignal);
            this.emit('signal', aggregatedSignal);
            
            this.logger.info(`üéØ New signal: ${symbol} ${aggregatedSignal.direction} (Confidence: ${aggregatedSignal.confidence.toFixed(3)})`);
        }
    }
    
    private async generateMLPriceSignal(symbol: string, data: MarketDataPoint[]): Promise<TradingSignal | null> {
        if (!this.mlModels.pricePredictor || data.length < 60) return null;
        
        try {
            // Prepare data for prediction
            const features = this.prepareMLFeatures(data.slice(-60));
            const input = tf.tensor3d([features], [1, 60, 8]);
            
            // Make prediction
            const prediction = this.mlModels.pricePredictor.predict(input) as tf.Tensor;
            const predictedPrice = await prediction.data();
            
            const currentPrice = data[data.length - 1].price;
            const priceChange = (predictedPrice[0] - currentPrice) / currentPrice;
            
            // Generate signal based on prediction
            let direction: 'BUY' | 'SELL' | 'HOLD' = 'HOLD';
            let strength = 0;
            let confidence = 0;
            
            if (Math.abs(priceChange) > 0.005) { // 0.5% threshold
                direction = priceChange > 0 ? 'BUY' : 'SELL';
                strength = Math.min(Math.abs(priceChange) * 10, 1);
                confidence = Math.min(strength * 1.2, 1);
            }
            
            // Clean up tensors
            input.dispose();
            prediction.dispose();
            
            if (direction === 'HOLD') return null;
            
            return {
                id: `ml_price_${symbol}_${Date.now()}`,
                symbol,
                timestamp: Date.now(),
                direction,
                strength,
                confidence,
                timeframe: '1m',
                source: 'ml_price_prediction',
                metadata: {
                    indicators: {
                        predicted_price: predictedPrice[0],
                        price_change: priceChange,
                        current_price: currentPrice
                    },
                    patterns: ['ml_price_prediction'],
                    riskLevel: strength > 0.7 ? 'HIGH' : strength > 0.4 ? 'MEDIUM' : 'LOW',
                    expectedReturn: Math.abs(priceChange),
                    stopLoss: currentPrice * (1 - (direction === 'BUY' ? 0.02 : -0.02)),
                    takeProfit: currentPrice * (1 + (direction === 'BUY' ? 0.03 : -0.03))
                }
            };
            
        } catch (error) {
            this.logger.error('Error in ML price prediction:', error);
            return null;
        }
    }
    
    private async generatePatternSignal(symbol: string, data: MarketDataPoint[]): Promise<TradingSignal | null> {
        if (!this.mlModels.patternDetector || data.length < 50) return null;
        
        try {
            // Prepare candlestick data
            const candleData = this.prepareCandleFeatures(data.slice(-50));
            const input = tf.tensor3d([candleData], [1, 50, 5]);
            
            // Pattern detection
            const prediction = this.mlModels.patternDetector.predict(input) as tf.Tensor;
            const probabilities = await prediction.data();
            
            // Find strongest signal
            const maxProb = Math.max(...probabilities);
            const maxIndex = Array.from(probabilities).indexOf(maxProb);
            
            // Clean up
            input.dispose();
            prediction.dispose();
            
            if (maxProb < 0.6) return null; // Low confidence
            
            const directions = ['BUY', 'SELL', 'HOLD'];
            const direction = directions[maxIndex] as 'BUY' | 'SELL' | 'HOLD';
            
            if (direction === 'HOLD') return null;
            
            return {
                id: `pattern_${symbol}_${Date.now()}`,
                symbol,
                timestamp: Date.now(),
                direction,
                strength: maxProb,
                confidence: maxProb,
                timeframe: '5m',
                source: 'pattern_detection',
                metadata: {
                    indicators: {
                        pattern_confidence: maxProb,
                        buy_prob: probabilities[0],
                        sell_prob: probabilities[1],
                        hold_prob: probabilities[2]
                    },
                    patterns: ['cnn_pattern_detection'],
                    riskLevel: maxProb > 0.8 ? 'HIGH' : 'MEDIUM',
                    expectedReturn: maxProb * 0.02,
                    stopLoss: data[data.length - 1].price * (1 - (direction === 'BUY' ? 0.015 : -0.015)),
                    takeProfit: data[data.length - 1].price * (1 + (direction === 'BUY' ? 0.025 : -0.025))
                }
            };
            
        } catch (error) {
            this.logger.error('Error in pattern detection:', error);
            return null;
        }
    }
    
    private async generateVolatilitySignal(symbol: string, data: MarketDataPoint[]): Promise<TradingSignal | null> {
        if (data.length < 20) return null;
        
        const recentData = data.slice(-20);
        const avgVolatility = recentData.reduce((sum, d) => sum + d.volatility, 0) / recentData.length;
        const currentVolatility = data[data.length - 1].volatility;
        
        // Volatility breakout detection
        if (currentVolatility > avgVolatility * 1.5) {
            const priceChange = (data[data.length - 1].price - data[data.length - 2].price) / data[data.length - 2].price;
            
            return {
                id: `volatility_${symbol}_${Date.now()}`,
                symbol,
                timestamp: Date.now(),
                direction: priceChange > 0 ? 'BUY' : 'SELL',
                strength: Math.min(currentVolatility / avgVolatility / 2, 1),
                confidence: 0.6 + Math.min(currentVolatility / avgVolatility / 5, 0.3),
                timeframe: '1m',
                source: 'volatility_breakout',
                metadata: {
                    indicators: {
                        current_volatility: currentVolatility,
                        avg_volatility: avgVolatility,
                        volatility_ratio: currentVolatility / avgVolatility,
                        price_change: priceChange
                    },
                    patterns: ['volatility_breakout'],
                    riskLevel: 'HIGH',
                    expectedReturn: Math.abs(priceChange) * 1.5,
                    stopLoss: data[data.length - 1].price * (1 - (priceChange > 0 ? 0.01 : -0.01)),
                    takeProfit: data[data.length - 1].price * (1 + (priceChange > 0 ? 0.02 : -0.02))
                }
            };
        }
        
        return null;
    }
    
    private async generateMomentumSignal(symbol: string, data: MarketDataPoint[]): Promise<TradingSignal | null> {
        if (data.length < 14) return null;
        
        // Simple momentum calculation
        const recentData = data.slice(-14);
        const rsi = this.calculateRSI(recentData.map(d => d.price));
        const macd = this.calculateMACD(data.slice(-26).map(d => d.price));
        
        let direction: 'BUY' | 'SELL' | 'HOLD' = 'HOLD';
        let strength = 0;
        
        if (rsi < 30 && macd.signal > 0) {
            direction = 'BUY';
            strength = (30 - rsi) / 30;
        } else if (rsi > 70 && macd.signal < 0) {
            direction = 'SELL';
            strength = (rsi - 70) / 30;
        }
        
        if (direction === 'HOLD') return null;
        
        return {
            id: `momentum_${symbol}_${Date.now()}`,
            symbol,
            timestamp: Date.now(),
            direction,
            strength,
            confidence: 0.5 + strength * 0.3,
            timeframe: '15m',
            source: 'momentum_signal',
            metadata: {
                indicators: {
                    rsi,
                    macd: macd.macd,
                    macd_signal: macd.signal,
                    macd_histogram: macd.histogram
                },
                patterns: ['rsi_oversold', 'rsi_overbought', 'macd_bullish', 'macd_bearish'],
                riskLevel: 'MEDIUM',
                expectedReturn: strength * 0.015,
                stopLoss: data[data.length - 1].price * (1 - (direction === 'BUY' ? 0.02 : -0.02)),
                takeProfit: data[data.length - 1].price * (1 + (direction === 'BUY' ? 0.03 : -0.03))
            }
        };
    }
    
    private async generateMeanReversionSignal(symbol: string, data: MarketDataPoint[]): Promise<TradingSignal | null> {
        if (data.length < 20) return null;
        
        const prices = data.slice(-20).map(d => d.price);
        const sma20 = prices.reduce((sum, price) => sum + price, 0) / prices.length;
        const currentPrice = data[data.length - 1].price;
        const deviation = (currentPrice - sma20) / sma20;
        
        // Mean reversion opportunity
        if (Math.abs(deviation) > 0.02) { // 2% deviation
            return {
                id: `mean_reversion_${symbol}_${Date.now()}`,
                symbol,
                timestamp: Date.now(),
                direction: deviation > 0 ? 'SELL' : 'BUY', // Revert to mean
                strength: Math.min(Math.abs(deviation) * 10, 1),
                confidence: 0.4 + Math.min(Math.abs(deviation) * 5, 0.4),
                timeframe: '30m',
                source: 'mean_reversion',
                metadata: {
                    indicators: {
                        sma20,
                        current_price: currentPrice,
                        deviation,
                        deviation_pct: deviation * 100
                    },
                    patterns: ['mean_reversion'],
                    riskLevel: 'LOW',
                    expectedReturn: Math.abs(deviation) * 0.5,
                    stopLoss: currentPrice * (1 - (deviation < 0 ? 0.01 : -0.01)),
                    takeProfit: sma20
                }
            };
        }
        
        return null;
    }
    
    // ========================================================================
    // üîß UTILITY METHODS
    // ========================================================================
    
    private prepareMLFeatures(data: MarketDataPoint[]): number[][] {
        return data.map(point => [
            point.price,
            point.volume,
            point.bid,
            point.ask,
            point.spread,
            point.change24h,
            point.volatility,
            Date.now() - point.timestamp // Time since data point
        ]);
    }
    
    private prepareCandleFeatures(data: MarketDataPoint[]): number[][] {
        return data.map((point, index) => {
            const prev = index > 0 ? data[index - 1] : point;
            return [
                prev.price, // Open (previous close)
                Math.max(point.price, prev.price), // High
                Math.min(point.price, prev.price), // Low
                point.price, // Close
                point.volume
            ];
        });
    }
    
    private calculateRSI(prices: number[], period: number = 14): number {
        if (prices.length < period + 1) return 50;
        
        let gains = 0;
        let losses = 0;
        
        for (let i = 1; i <= period; i++) {
            const change = prices[i] - prices[i - 1];
            if (change > 0) gains += change;
            else losses -= change;
        }
        
        const avgGain = gains / period;
        const avgLoss = losses / period;
        
        if (avgLoss === 0) return 100;
        
        const rs = avgGain / avgLoss;
        return 100 - (100 / (1 + rs));
    }
    
    private calculateMACD(prices: number[]): { macd: number; signal: number; histogram: number } {
        if (prices.length < 26) return { macd: 0, signal: 0, histogram: 0 };
        
        const ema12 = this.calculateEMA(prices, 12);
        const ema26 = this.calculateEMA(prices, 26);
        const macd = ema12 - ema26;
        
        // Simple signal line (9-period EMA of MACD)
        const signal = macd * 0.2; // Simplified
        const histogram = macd - signal;
        
        return { macd, signal, histogram };
    }
    
    private calculateEMA(prices: number[], period: number): number {
        if (prices.length === 0) return 0;
        
        const multiplier = 2 / (period + 1);
        let ema = prices[0];
        
        for (let i = 1; i < prices.length; i++) {
            ema = (prices[i] * multiplier) + (ema * (1 - multiplier));
        }
        
        return ema;
    }
    
    private startSignalProcessing(): void {
        // Process signals every second
        setInterval(() => {
            this.processActiveSignals();
        }, 1000);
    }
    
    private processActiveSignals(): void {
        const now = Date.now();
        const expiredSignals: string[] = [];
        
        for (const [signalId, signal] of this.activeSignals) {
            // Remove signals older than 5 minutes
            if (now - signal.timestamp > 300000) {
                expiredSignals.push(signalId);
            }
        }
        
        expiredSignals.forEach(id => {
            this.activeSignals.delete(id);
        });
    }
    
    // ========================================================================
    // üìä PUBLIC METHODS
    // ========================================================================
    
    getActiveSignals(): TradingSignal[] {
        return Array.from(this.activeSignals.values());
    }
    
    getSignalsForSymbol(symbol: string): TradingSignal[] {
        return Array.from(this.activeSignals.values()).filter(signal => signal.symbol === symbol);
    }
    
    getPerformanceMetrics(): Map<string, SignalPerformance> {
        return this.signalPerformance;
    }
    
    isSystemActive(): boolean {
        return this.isActive;
    }
}

// ============================================================================
// üéØ SIGNAL AGGREGATOR
// ============================================================================

class SignalAggregator {
    async aggregate(signals: TradingSignal[], symbol: string): Promise<TradingSignal | null> {
        if (signals.length === 0) return null;
        
        // Group signals by direction
        const buySignals = signals.filter(s => s.direction === 'BUY');
        const sellSignals = signals.filter(s => s.direction === 'SELL');
        
        // Determine dominant direction
        let dominantDirection: 'BUY' | 'SELL';
        let relevantSignals: TradingSignal[];
        
        if (buySignals.length > sellSignals.length) {
            dominantDirection = 'BUY';
            relevantSignals = buySignals;
        } else if (sellSignals.length > buySignals.length) {
            dominantDirection = 'SELL';
            relevantSignals = sellSignals;
        } else {
            // Equal signals, choose based on confidence
            const buyConfidence = buySignals.reduce((sum, s) => sum + s.confidence, 0);
            const sellConfidence = sellSignals.reduce((sum, s) => sum + s.confidence, 0);
            
            if (buyConfidence > sellConfidence) {
                dominantDirection = 'BUY';
                relevantSignals = buySignals;
            } else {
                dominantDirection = 'SELL';
                relevantSignals = sellSignals;
            }
        }
        
        // Calculate aggregated metrics
        const avgStrength = relevantSignals.reduce((sum, s) => sum + s.strength, 0) / relevantSignals.length;
        const avgConfidence = relevantSignals.reduce((sum, s) => sum + s.confidence, 0) / relevantSignals.length;
        
        // Apply ensemble boost
        const ensembleBoost = Math.min(relevantSignals.length * 0.1, 0.3);
        const finalConfidence = Math.min(avgConfidence + ensembleBoost, 1);
        
        return {
            id: `aggregated_${symbol}_${Date.now()}`,
            symbol,
            timestamp: Date.now(),
            direction: dominantDirection,
            strength: avgStrength,
            confidence: finalConfidence,
            timeframe: 'aggregated',
            source: 'signal_aggregator',
            metadata: {
                indicators: {
                    signal_count: relevantSignals.length,
                    ensemble_boost: ensembleBoost,
                    source_list: relevantSignals.map(s => s.source).join(',')
                },
                patterns: ['ensemble_aggregation'],
                riskLevel: finalConfidence > 0.8 ? 'HIGH' : finalConfidence > 0.6 ? 'MEDIUM' : 'LOW',
                expectedReturn: avgStrength * 0.02,
                stopLoss: 0,
                takeProfit: 0
            }
        };
    }
}

// ============================================================================
// üìà PERFORMANCE TRACKER
// ============================================================================

class PerformanceTracker {
    private signalHistory: Map<string, TradingSignal[]> = new Map();
    private performanceData: Map<string, SignalPerformance> = new Map();
    
    trackSignal(signal: TradingSignal): void {
        const source = signal.source;
        
        if (!this.signalHistory.has(source)) {
            this.signalHistory.set(source, []);
        }
        
        this.signalHistory.get(source)!.push(signal);
        this.updatePerformanceMetrics(source);
    }
    
    private updatePerformanceMetrics(source: string): void {
        const signals = this.signalHistory.get(source) || [];
        if (signals.length === 0) return;
        
        // Mock performance calculation (in real system, would track actual trades)
        const accuracy = 0.6 + Math.random() * 0.3; // 60-90%
        const profitability = 0.5 + Math.random() * 0.4; // 50-90%
        const winRate = accuracy;
        const avgReturn = 0.01 + Math.random() * 0.02; // 1-3%
        
        const performance: SignalPerformance = {
            signalId: source,
            source,
            accuracy,
            profitability,
            sharpeRatio: profitability / 0.15, // Mock Sharpe
            maxDrawdown: 0.05 + Math.random() * 0.1, // 5-15%
            totalTrades: signals.length,
            winRate,
            avgReturn,
            reliability: (accuracy + profitability + winRate) / 3
        };
        
        this.performanceData.set(source, performance);
    }
    
    getPerformance(source: string): SignalPerformance | undefined {
        return this.performanceData.get(source);
    }
    
    getAllPerformance(): Map<string, SignalPerformance> {
        return this.performanceData;
    }
}

// ============================================================================
// üöÄ EXPORT
// ============================================================================

// Example usage:
if (require.main === module) {
    const signalSystem = new AdvancedRealTimeTradingSignals({
        symbols: ['BTCUSDT', 'ETHUSDT', 'ADAUSDT'],
        reconnectDelay: 3000
    });
    
    signalSystem.on('signal', (signal: TradingSignal) => {
        console.log(`üéØ New Signal: ${signal.symbol} ${signal.direction} (${(signal.confidence * 100).toFixed(1)}%)`);
    });
    
    signalSystem.start();
}
