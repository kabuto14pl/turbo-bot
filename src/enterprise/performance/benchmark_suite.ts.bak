/**
 * Enterprise Performance Benchmarking Suite
 * Comprehensive latency measurement, throughput analysis, and regression testing
 */

import { EventEmitter } from 'events';
import { performance, PerformanceObserver } from 'perf_hooks';
import * as fs from 'fs';
import * as path from 'path';

interface BenchmarkConfig {
    name: string;
    iterations: number;
    warmupIterations: number;
    concurrency: number;
    timeout: number;
    tags: string[];
}

interface BenchmarkResult {
    name: string;
    config: BenchmarkConfig;
    startTime: number;
    endTime: number;
    totalDuration: number;
    iterations: number;
    successfulIterations: number;
    failedIterations: number;
    metrics: PerformanceMetrics;
    memoryProfile: MemoryProfile;
    regressionAnalysis: RegressionAnalysis;
    percentiles: PercentileMetrics;
}

interface PerformanceMetrics {
    averageLatency: number;
    medianLatency: number;
    minLatency: number;
    maxLatency: number;
    standardDeviation: number;
    throughput: number; // operations per second
    errorRate: number;
    cpuUsage: CpuMetrics;
}

interface MemoryProfile {
    initialHeap: number;
    finalHeap: number;
    peakHeap: number;
    averageHeap: number;
    heapGrowth: number;
    gcEvents: number;
    gcDuration: number;
}

interface CpuMetrics {
    averageUsage: number;
    peakUsage: number;
    userTime: number;
    systemTime: number;
}

interface RegressionAnalysis {
    isRegression: boolean;
    baselineComparison: BaselineComparison | null;
    regressionSeverity: 'none' | 'minor' | 'moderate' | 'severe';
    affectedMetrics: string[];
}

interface BaselineComparison {
    baselineDate: string;
    latencyChange: number;
    throughputChange: number;
    memoryChange: number;
    cpuChange: number;
}

interface PercentileMetrics {
    p50: number;
    p75: number;
    p90: number;
    p95: number;
    p99: number;
    p999: number;
}

interface BenchmarkSuite {
    name: string;
    benchmarks: BenchmarkDefinition[];
    baselineFile?: string;
}

interface BenchmarkDefinition {
    name: string;
    category: string;
    setup?: () => Promise<void>;
    test: () => Promise<any>;
    teardown?: () => Promise<void>;
    config: Partial<BenchmarkConfig>;
}

export class EnterpriseBenchmarkSuite extends EventEmitter {
    private results: Map<string, BenchmarkResult[]> = new Map();
    private baselines: Map<string, BenchmarkResult> = new Map();
    private currentBaseline: string | null = null;
    private performanceObserver: PerformanceObserver | null = null;

    constructor() {
        super();
        this.setupPerformanceObserver();
    }

    private setupPerformanceObserver(): void {
        try {
            if (typeof PerformanceObserver !== 'undefined') {
                this.performanceObserver = new PerformanceObserver((list) => {
                    const entries = list.getEntries();
                    for (const entry of entries) {
                        if (entry.entryType === 'measure') {
                            this.emit('measure', {
                                name: entry.name,
                                duration: entry.duration,
                                startTime: entry.startTime
                            });
                        }
                    }
                });
                this.performanceObserver.observe({ entryTypes: ['measure'] });
            } else {
                console.warn('PerformanceObserver not available in this environment');
            }
        } catch (error) {
            console.warn('Failed to setup PerformanceObserver:', error);
        }
    }

    public async runBenchmark(
        name: string,
        testFunction: () => Promise<any>,
        config: Partial<BenchmarkConfig> = {}
    ): Promise<BenchmarkResult> {
        const fullConfig: BenchmarkConfig = {
            name,
            iterations: 1000,
            warmupIterations: 100,
            concurrency: 1,
            timeout: 30000,
            tags: [],
            ...config
        };

        console.log(`[BENCHMARK] Starting benchmark: ${name}`);
        console.log(`[BENCHMARK] Config: ${fullConfig.iterations} iterations, ${fullConfig.concurrency} concurrency`);

        const result = await this.executeBenchmark(testFunction, fullConfig);
        
        // Store result
        if (!this.results.has(name)) {
            this.results.set(name, []);
        }
        this.results.get(name)!.push(result);

        // Perform regression analysis
        result.regressionAnalysis = this.analyzeRegression(name, result);

        console.log(`[BENCHMARK] Completed: ${name}`);
        this.logBenchmarkResult(result);

        this.emit('benchmarkCompleted', result);
        return result;
    }

    private async executeBenchmark(
        testFunction: () => Promise<any>,
        config: BenchmarkConfig
    ): Promise<BenchmarkResult> {
        const measurements: number[] = [];
        const memorySnapshots: number[] = [];
        let successfulIterations = 0;
        let failedIterations = 0;
        let gcEvents = 0;
        let gcDuration = 0;

        // Setup GC monitoring
        const gcObserver = new PerformanceObserver((list) => {
            const entries = list.getEntries();
            entries.forEach((entry: any) => {
                if (entry.entryType === 'gc') {
                    gcEvents++;
                    gcDuration += entry.duration;
                }
            });
        });
        gcObserver.observe({ entryTypes: ['gc'] });

        const initialMemory = process.memoryUsage();
        let peakMemory = initialMemory.heapUsed;
        
        const startTime = performance.now();
        const initialCpuUsage = process.cpuUsage();

        // Warmup phase
        console.log(`[BENCHMARK] Warming up (${config.warmupIterations} iterations)...`);
        for (let i = 0; i < config.warmupIterations; i++) {
            try {
                await testFunction();
            } catch (error) {
                // Ignore warmup errors
            }
        }

        // Main benchmark phase
        console.log(`[BENCHMARK] Running main benchmark (${config.iterations} iterations)...`);
        
        if (config.concurrency === 1) {
            // Sequential execution
            for (let i = 0; i < config.iterations; i++) {
                const iterationStart = performance.now();
                
                try {
                    await testFunction();
                    const iterationEnd = performance.now();
                    measurements.push(iterationEnd - iterationStart);
                    successfulIterations++;
                } catch (error) {
                    failedIterations++;
                }

                // Track memory usage
                const currentMemory = process.memoryUsage().heapUsed;
                memorySnapshots.push(currentMemory);
                if (currentMemory > peakMemory) {
                    peakMemory = currentMemory;
                }

                // Progress reporting
                if ((i + 1) % Math.max(1, Math.floor(config.iterations / 10)) === 0) {
                    const progress = ((i + 1) / config.iterations * 100).toFixed(1);
                    console.log(`[BENCHMARK] Progress: ${progress}% (${i + 1}/${config.iterations})`);
                }
            }
        } else {
            // Concurrent execution
            const concurrentPromises: Promise<void>[] = [];
            const semaphore = new Array(config.concurrency).fill(null);
            
            for (let i = 0; i < config.iterations; i++) {
                const promise = this.executeConcurrentIteration(testFunction, measurements, i);
                concurrentPromises.push(promise);
                
                if (concurrentPromises.length >= config.concurrency) {
                    await Promise.race(concurrentPromises);
                    // Remove completed promises
                    for (let j = concurrentPromises.length - 1; j >= 0; j--) {
                        if (await this.isPromiseResolved(concurrentPromises[j])) {
                            concurrentPromises.splice(j, 1);
                        }
                    }
                }
            }
            
            // Wait for remaining promises
            await Promise.all(concurrentPromises);
            successfulIterations = measurements.length;
            failedIterations = config.iterations - successfulIterations;
        }

        const endTime = performance.now();
        const finalCpuUsage = process.cpuUsage(initialCpuUsage);
        const finalMemory = process.memoryUsage();

        gcObserver.disconnect();

        // Calculate metrics
        const totalDuration = endTime - startTime;
        const metrics = this.calculateMetrics(measurements, totalDuration);
        const memoryProfile = this.calculateMemoryProfile(
            initialMemory, finalMemory, memorySnapshots, peakMemory, gcEvents, gcDuration
        );
        const cpuMetrics = this.calculateCpuMetrics(finalCpuUsage, totalDuration);
        const percentiles = this.calculatePercentiles(measurements);

        return {
            name: config.name,
            config,
            startTime,
            endTime,
            totalDuration,
            iterations: config.iterations,
            successfulIterations,
            failedIterations,
            metrics: {
                ...metrics,
                cpuUsage: cpuMetrics
            },
            memoryProfile,
            regressionAnalysis: {
                isRegression: false,
                baselineComparison: null,
                regressionSeverity: 'none',
                affectedMetrics: []
            },
            percentiles
        };
    }

    private async executeConcurrentIteration(
        testFunction: () => Promise<any>,
        measurements: number[],
        index: number
    ): Promise<void> {
        const start = performance.now();
        try {
            await testFunction();
            const end = performance.now();
            measurements.push(end - start);
        } catch (error) {
            // Error will be counted in failed iterations
        }
    }

    private async isPromiseResolved(promise: Promise<any>): Promise<boolean> {
        try {
            await Promise.race([promise, new Promise(resolve => setTimeout(resolve, 0))]);
            return true;
        } catch {
            return true; // Consider rejected promises as resolved for counting purposes
        }
    }

    private calculateMetrics(measurements: number[], totalDuration: number): Omit<PerformanceMetrics, 'cpuUsage'> {
        if (measurements.length === 0) {
            return {
                averageLatency: 0,
                medianLatency: 0,
                minLatency: 0,
                maxLatency: 0,
                standardDeviation: 0,
                throughput: 0,
                errorRate: 100
            };
        }

        const sorted = [...measurements].sort((a, b) => a - b);
        const sum = measurements.reduce((a, b) => a + b, 0);
        const average = sum / measurements.length;
        const median = sorted[Math.floor(sorted.length / 2)];
        const variance = measurements.reduce((acc, val) => acc + Math.pow(val - average, 2), 0) / measurements.length;
        const standardDeviation = Math.sqrt(variance);

        return {
            averageLatency: average,
            medianLatency: median,
            minLatency: Math.min(...measurements),
            maxLatency: Math.max(...measurements),
            standardDeviation,
            throughput: (measurements.length / totalDuration) * 1000, // ops per second
            errorRate: 0 // Will be calculated by caller
        };
    }

    private calculateMemoryProfile(
        initial: NodeJS.MemoryUsage,
        final: NodeJS.MemoryUsage,
        snapshots: number[],
        peak: number,
        gcEvents: number,
        gcDuration: number
    ): MemoryProfile {
        const average = snapshots.length > 0 ? snapshots.reduce((a, b) => a + b, 0) / snapshots.length : initial.heapUsed;
        
        return {
            initialHeap: initial.heapUsed,
            finalHeap: final.heapUsed,
            peakHeap: peak,
            averageHeap: average,
            heapGrowth: final.heapUsed - initial.heapUsed,
            gcEvents,
            gcDuration
        };
    }

    private calculateCpuMetrics(cpuUsage: NodeJS.CpuUsage, duration: number): CpuMetrics {
        const totalCpuTime = cpuUsage.user + cpuUsage.system;
        const cpuUsagePercent = (totalCpuTime / (duration * 1000)) * 100; // Convert to percentage

        return {
            averageUsage: cpuUsagePercent,
            peakUsage: cpuUsagePercent, // Simplified - would need continuous monitoring
            userTime: cpuUsage.user,
            systemTime: cpuUsage.system
        };
    }

    private calculatePercentiles(measurements: number[]): PercentileMetrics {
        if (measurements.length === 0) {
            return { p50: 0, p75: 0, p90: 0, p95: 0, p99: 0, p999: 0 };
        }

        const sorted = [...measurements].sort((a, b) => a - b);
        const getPercentile = (p: number) => {
            const index = Math.ceil((p / 100) * sorted.length) - 1;
            return sorted[Math.max(0, index)];
        };

        return {
            p50: getPercentile(50),
            p75: getPercentile(75),
            p90: getPercentile(90),
            p95: getPercentile(95),
            p99: getPercentile(99),
            p999: getPercentile(99.9)
        };
    }

    private analyzeRegression(name: string, result: BenchmarkResult): RegressionAnalysis {
        const baseline = this.baselines.get(name);
        if (!baseline) {
            return {
                isRegression: false,
                baselineComparison: null,
                regressionSeverity: 'none',
                affectedMetrics: []
            };
        }

        const latencyChange = ((result.metrics.averageLatency - baseline.metrics.averageLatency) / baseline.metrics.averageLatency) * 100;
        const throughputChange = ((result.metrics.throughput - baseline.metrics.throughput) / baseline.metrics.throughput) * 100;
        const memoryChange = ((result.memoryProfile.averageHeap - baseline.memoryProfile.averageHeap) / baseline.memoryProfile.averageHeap) * 100;
        const cpuChange = ((result.metrics.cpuUsage.averageUsage - baseline.metrics.cpuUsage.averageUsage) / baseline.metrics.cpuUsage.averageUsage) * 100;

        const comparison: BaselineComparison = {
            baselineDate: new Date(baseline.startTime).toISOString(),
            latencyChange,
            throughputChange,
            memoryChange,
            cpuChange
        };

        const affectedMetrics: string[] = [];
        let isRegression = false;
        let severity: 'none' | 'minor' | 'moderate' | 'severe' = 'none';

        // Define regression thresholds
        if (latencyChange > 20) {
            affectedMetrics.push('latency');
            isRegression = true;
            severity = latencyChange > 50 ? 'severe' : 'moderate';
        }

        if (throughputChange < -15) {
            affectedMetrics.push('throughput');
            isRegression = true;
            if (severity === 'none') severity = throughputChange < -30 ? 'severe' : 'moderate';
        }

        if (memoryChange > 25) {
            affectedMetrics.push('memory');
            isRegression = true;
            if (severity === 'none') severity = memoryChange > 50 ? 'severe' : 'moderate';
        }

        if (cpuChange > 20) {
            affectedMetrics.push('cpu');
            isRegression = true;
            if (severity === 'none') severity = cpuChange > 40 ? 'severe' : 'moderate';
        }

        // Minor regression if any metric is slightly degraded
        if (!isRegression && (latencyChange > 10 || throughputChange < -10 || memoryChange > 15 || cpuChange > 15)) {
            isRegression = true;
            severity = 'minor';
        }

        return {
            isRegression,
            baselineComparison: comparison,
            regressionSeverity: severity,
            affectedMetrics
        };
    }

    public setBaseline(name: string, result?: BenchmarkResult): void {
        if (result) {
            this.baselines.set(name, result);
        } else {
            const results = this.results.get(name);
            if (results && results.length > 0) {
                this.baselines.set(name, results[results.length - 1]);
            }
        }
        console.log(`[BENCHMARK] Baseline set for: ${name}`);
    }

    public loadBaseline(filePath: string): void {
        try {
            const data = fs.readFileSync(filePath, 'utf8');
            const baselines = JSON.parse(data);
            
            Object.keys(baselines).forEach(name => {
                this.baselines.set(name, baselines[name]);
            });
            
            console.log(`[BENCHMARK] Loaded baselines from: ${filePath}`);
        } catch (error) {
            console.error(`[BENCHMARK] Failed to load baseline: ${error}`);
        }
    }

    public saveBaseline(filePath: string): void {
        try {
            const baselineData: Record<string, BenchmarkResult> = {};
            this.baselines.forEach((result, name) => {
                baselineData[name] = result;
            });

            const dir = path.dirname(filePath);
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
            }

            fs.writeFileSync(filePath, JSON.stringify(baselineData, null, 2));
            console.log(`[BENCHMARK] Saved baselines to: ${filePath}`);
        } catch (error) {
            console.error(`[BENCHMARK] Failed to save baseline: ${error}`);
        }
    }

    public async runBenchmarkSuite(suite: BenchmarkSuite): Promise<BenchmarkResult[]> {
        console.log(`[BENCHMARK SUITE] Starting suite: ${suite.name}`);
        
        if (suite.baselineFile) {
            this.loadBaseline(suite.baselineFile);
        }

        const results: BenchmarkResult[] = [];

        for (const benchmark of suite.benchmarks) {
            try {
                if (benchmark.setup) {
                    await benchmark.setup();
                }

                const result = await this.runBenchmark(
                    benchmark.name,
                    benchmark.test,
                    benchmark.config
                );

                results.push(result);

                if (benchmark.teardown) {
                    await benchmark.teardown();
                }

            } catch (error) {
                console.error(`[BENCHMARK SUITE] Failed to run ${benchmark.name}:`, error);
            }
        }

        console.log(`[BENCHMARK SUITE] Completed suite: ${suite.name}`);
        this.generateSuiteReport(suite.name, results);

        return results;
    }

    private generateSuiteReport(suiteName: string, results: BenchmarkResult[]): void {
        const reportPath = path.join(process.cwd(), 'monitoring', 'benchmark_reports', `${suiteName}-${Date.now()}.json`);
        
        const report = {
            suiteName,
            timestamp: new Date().toISOString(),
            totalBenchmarks: results.length,
            summary: this.generateSummary(results),
            results,
            regressions: results.filter(r => r.regressionAnalysis.isRegression)
        };

        const dir = path.dirname(reportPath);
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }

        fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
        console.log(`[BENCHMARK SUITE] Report saved: ${reportPath}`);
    }

    private generateSummary(results: BenchmarkResult[]): any {
        const totalIterations = results.reduce((sum, r) => sum + r.iterations, 0);
        const avgLatency = results.reduce((sum, r) => sum + r.metrics.averageLatency, 0) / results.length;
        const avgThroughput = results.reduce((sum, r) => sum + r.metrics.throughput, 0) / results.length;
        const regressions = results.filter(r => r.regressionAnalysis.isRegression);

        return {
            totalIterations,
            averageLatency: avgLatency,
            averageThroughput: avgThroughput,
            regressionsFound: regressions.length,
            severeRegressions: regressions.filter(r => r.regressionAnalysis.regressionSeverity === 'severe').length
        };
    }

    private logBenchmarkResult(result: BenchmarkResult): void {
        console.log('\n=== BENCHMARK RESULT ===');
        console.log(`Name: ${result.name}`);
        console.log(`Iterations: ${result.iterations} (${result.successfulIterations} successful)`);
        console.log(`Duration: ${result.totalDuration.toFixed(2)}ms`);
        console.log(`Average Latency: ${result.metrics.averageLatency.toFixed(2)}ms`);
        console.log(`Median Latency: ${result.metrics.medianLatency.toFixed(2)}ms`);
        console.log(`95th Percentile: ${result.percentiles.p95.toFixed(2)}ms`);
        console.log(`99th Percentile: ${result.percentiles.p99.toFixed(2)}ms`);
        console.log(`Throughput: ${result.metrics.throughput.toFixed(2)} ops/sec`);
        console.log(`Memory Growth: ${(result.memoryProfile.heapGrowth / 1024 / 1024).toFixed(2)}MB`);
        console.log(`GC Events: ${result.memoryProfile.gcEvents}`);
        
        if (result.regressionAnalysis.isRegression) {
            console.log(`⚠️  REGRESSION DETECTED (${result.regressionAnalysis.regressionSeverity})`);
            console.log(`Affected metrics: ${result.regressionAnalysis.affectedMetrics.join(', ')}`);
        }
        console.log('========================\n');
    }

    public getResults(benchmarkName?: string): BenchmarkResult[] {
        if (benchmarkName) {
            return this.results.get(benchmarkName) || [];
        }
        
        const allResults: BenchmarkResult[] = [];
        this.results.forEach(results => {
            allResults.push(...results);
        });
        return allResults;
    }

    public clearResults(): void {
        this.results.clear();
    }

    public disconnect(): void {
        if (this.performanceObserver) {
            this.performanceObserver.disconnect();
            this.performanceObserver = null;
        }
    }
}
