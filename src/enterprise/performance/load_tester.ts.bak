/**
 * Enterprise Load Testing Framework
 * Comprehensive stress testing for trading bot with high-frequency data simulation
 * Features: Concurrent strategy testing, market data simulation, performance benchmarking
 */

import { EventEmitter } from 'events';
import * as cluster from 'cluster';
import * as os from 'os';

interface LoadTestConfig {
    name: string;
    duration: number; // seconds
    concurrency: number;
    rampUpTime: number; // seconds
    targetTPS: number; // transactions per second
    dataFrequency: number; // market data updates per second
    scenarios: LoadTestScenario[];
}

interface LoadTestScenario {
    name: string;
    weight: number; // percentage of total load
    actions: ScenarioAction[];
    validation: ValidationRule[];
}

interface ScenarioAction {
    type: 'market_data' | 'place_order' | 'cancel_order' | 'portfolio_check' | 'strategy_signal';
    params: any;
    delay?: number; // ms
}

interface ValidationRule {
    metric: string;
    operator: 'gt' | 'lt' | 'eq' | 'gte' | 'lte';
    value: number;
    severity: 'error' | 'warning';
}

interface LoadTestResult {
    testName: string;
    startTime: number;
    endTime: number;
    duration: number;
    totalRequests: number;
    successfulRequests: number;
    failedRequests: number;
    averageResponseTime: number;
    p95ResponseTime: number;
    p99ResponseTime: number;
    maxResponseTime: number;
    throughput: number; // requests per second
    errorRate: number;
    memoryUsage: MemoryMetrics;
    cpuUsage: CpuMetrics;
    validationResults: ValidationResult[];
    errors: LoadTestError[];
}

interface MemoryMetrics {
    peakHeapUsed: number;
    peakRSS: number;
    averageHeapUsed: number;
    gcCount: number;
    gcDuration: number;
}

interface CpuMetrics {
    peakCpuUsage: number;
    averageCpuUsage: number;
    systemLoad: number[];
}

interface ValidationResult {
    rule: ValidationRule;
    passed: boolean;
    actualValue: number;
    message: string;
}

interface LoadTestError {
    timestamp: number;
    type: string;
    message: string;
    stack?: string;
    context?: any;
}

export class EnterpriseLoadTester extends EventEmitter {
    private workers: cluster.Worker[] = [];
    private results: LoadTestResult[] = [];
    private currentTest: LoadTestConfig | null = null;
    private startTime: number = 0;
    private metrics: Map<string, number[]> = new Map();

    constructor(private maxWorkers: number = os.cpus().length) {
        super();
        this.setupClusterEvents();
    }

    private setupClusterEvents(): void {
        // Use isPrimary for newer Node.js versions, isMaster for compatibility
        const isPrimary = (cluster as any).isPrimary !== undefined ? (cluster as any).isPrimary : (cluster as any).isMaster;
        
        if (isPrimary) {
            (cluster as any).on('exit', (worker: any, code: any, signal: any) => {
                console.log(`[LOAD TESTER] Worker ${worker.process.pid} died (${signal || code})`);
                this.workers = this.workers.filter(w => w.id !== worker.id);
            });

            (cluster as any).on('message', (worker: any, message: any) => {
                this.handleWorkerMessage(worker, message);
            });
        }
    }

    private handleWorkerMessage(worker: cluster.Worker, message: any): void {
        switch (message.type) {
            case 'metrics':
                this.aggregateMetrics(message.data);
                break;
            case 'error':
                this.handleWorkerError(message.data);
                break;
            case 'completed':
                this.handleWorkerCompletion(worker, message.data);
                break;
        }
    }

    public async runLoadTest(config: LoadTestConfig): Promise<LoadTestResult> {
        console.log(`[LOAD TESTER] Starting load test: ${config.name}`);
        console.log(`[LOAD TESTER] Config: ${config.concurrency} workers, ${config.duration}s duration, ${config.targetTPS} TPS`);

        this.currentTest = config;
        this.startTime = Date.now();
        this.metrics.clear();

        // Start monitoring
        const monitoringInterval = this.startMonitoring();

        try {
            // Spawn worker processes
            await this.spawnWorkers(config);

            // Wait for test completion
            await this.waitForCompletion(config.duration);

            // Collect results
            const result = await this.collectResults();

            clearInterval(monitoringInterval);
            await this.cleanup();

            console.log(`[LOAD TESTER] Load test completed: ${result.testName}`);
            this.logResults(result);

            return result;

        } catch (error) {
            clearInterval(monitoringInterval);
            await this.cleanup();
            throw error;
        }
    }

    private async spawnWorkers(config: LoadTestConfig): Promise<void> {
        const workerCount = Math.min(config.concurrency, this.maxWorkers);
        const rampUpDelay = (config.rampUpTime * 1000) / workerCount;

        for (let i = 0; i < workerCount; i++) {
            // Ramp up workers gradually
            await new Promise(resolve => setTimeout(resolve, rampUpDelay));

            const worker = (cluster as any).fork({
                LOAD_TEST_CONFIG: JSON.stringify(config),
                WORKER_ID: i.toString(),
                WORKER_COUNT: workerCount.toString()
            });

            this.workers.push(worker);
            console.log(`[LOAD TESTER] Spawned worker ${worker.process.pid} (${i + 1}/${workerCount})`);
        }
    }

    private startMonitoring(): NodeJS.Timeout {
        return setInterval(() => {
            const memUsage = process.memoryUsage();
            const cpuUsage = process.cpuUsage();

            this.recordMetric('memory.heapUsed', memUsage.heapUsed);
            this.recordMetric('memory.rss', memUsage.rss);
            this.recordMetric('cpu.user', cpuUsage.user);
            this.recordMetric('cpu.system', cpuUsage.system);

        }, 1000); // Every second
    }

    private recordMetric(name: string, value: number): void {
        if (!this.metrics.has(name)) {
            this.metrics.set(name, []);
        }
        this.metrics.get(name)!.push(value);
    }

    private aggregateMetrics(data: any): void {
        Object.keys(data).forEach(key => {
            this.recordMetric(`worker.${key}`, data[key]);
        });
    }

    private handleWorkerError(error: LoadTestError): void {
        console.error(`[LOAD TESTER] Worker error: ${error.message}`);
        this.emit('error', error);
    }

    private handleWorkerCompletion(worker: cluster.Worker, data: any): void {
        console.log(`[LOAD TESTER] Worker ${worker.process.pid} completed`);
        this.emit('workerCompleted', data);
    }

    private async waitForCompletion(duration: number): Promise<void> {
        return new Promise((resolve) => {
            setTimeout(() => {
                console.log(`[LOAD TESTER] Test duration completed (${duration}s)`);
                resolve();
            }, duration * 1000);
        });
    }

    private async collectResults(): Promise<LoadTestResult> {
        const endTime = Date.now();
        const duration = (endTime - this.startTime) / 1000;

        // Calculate aggregated metrics
        const totalRequests = this.getMetricSum('worker.requests') || 0;
        const successfulRequests = this.getMetricSum('worker.success') || 0;
        const failedRequests = totalRequests - successfulRequests;
        const responseTimes = this.getAllMetricValues('worker.responseTime');

        const result: LoadTestResult = {
            testName: this.currentTest!.name,
            startTime: this.startTime,
            endTime,
            duration,
            totalRequests,
            successfulRequests,
            failedRequests,
            averageResponseTime: this.calculateAverage(responseTimes),
            p95ResponseTime: this.calculatePercentile(responseTimes, 95),
            p99ResponseTime: this.calculatePercentile(responseTimes, 99),
            maxResponseTime: Math.max(...responseTimes, 0),
            throughput: totalRequests / duration,
            errorRate: (failedRequests / totalRequests) * 100 || 0,
            memoryUsage: this.calculateMemoryMetrics(),
            cpuUsage: this.calculateCpuMetrics(),
            validationResults: this.validateResults(),
            errors: [] // Will be populated by workers
        };

        this.results.push(result);
        return result;
    }

    private getMetricSum(name: string): number {
        const values = this.metrics.get(name) || [];
        return values.reduce((sum, val) => sum + val, 0);
    }

    private getAllMetricValues(prefix: string): number[] {
        const values: number[] = [];
        this.metrics.forEach((metricValues, key) => {
            if (key.startsWith(prefix)) {
                values.push(...metricValues);
            }
        });
        return values;
    }

    private calculateAverage(values: number[]): number {
        if (values.length === 0) return 0;
        return values.reduce((sum, val) => sum + val, 0) / values.length;
    }

    private calculatePercentile(values: number[], percentile: number): number {
        if (values.length === 0) return 0;
        const sorted = values.sort((a, b) => a - b);
        const index = Math.ceil((percentile / 100) * sorted.length) - 1;
        return sorted[Math.max(0, index)];
    }

    private calculateMemoryMetrics(): MemoryMetrics {
        const heapValues = this.metrics.get('memory.heapUsed') || [];
        const rssValues = this.metrics.get('memory.rss') || [];

        return {
            peakHeapUsed: Math.max(...heapValues, 0),
            peakRSS: Math.max(...rssValues, 0),
            averageHeapUsed: this.calculateAverage(heapValues),
            gcCount: this.getMetricSum('worker.gcCount'),
            gcDuration: this.getMetricSum('worker.gcDuration')
        };
    }

    private calculateCpuMetrics(): CpuMetrics {
        const userValues = this.metrics.get('cpu.user') || [];
        const systemValues = this.metrics.get('cpu.system') || [];
        const totalCpu = userValues.map((user, i) => user + (systemValues[i] || 0));

        return {
            peakCpuUsage: Math.max(...totalCpu, 0),
            averageCpuUsage: this.calculateAverage(totalCpu),
            systemLoad: os.loadavg()
        };
    }

    private validateResults(): ValidationResult[] {
        const results: ValidationResult[] = [];
        
        if (!this.currentTest) return results;

        this.currentTest.scenarios.forEach(scenario => {
            scenario.validation.forEach(rule => {
                const actualValue = this.getValidationValue(rule.metric);
                const passed = this.evaluateValidationRule(rule, actualValue);
                
                results.push({
                    rule,
                    passed,
                    actualValue,
                    message: passed ? 'Validation passed' : `Validation failed: ${rule.metric} ${rule.operator} ${rule.value}`
                });
            });
        });

        return results;
    }

    private getValidationValue(metric: string): number {
        switch (metric) {
            case 'errorRate':
                return this.getMetricSum('worker.failed') / this.getMetricSum('worker.requests') * 100;
            case 'averageResponseTime':
                return this.calculateAverage(this.getAllMetricValues('worker.responseTime'));
            case 'throughput':
                const duration = (Date.now() - this.startTime) / 1000;
                return this.getMetricSum('worker.requests') / duration;
            case 'peakMemory':
                return Math.max(...(this.metrics.get('memory.heapUsed') || []), 0);
            default:
                return 0;
        }
    }

    private evaluateValidationRule(rule: ValidationRule, actualValue: number): boolean {
        switch (rule.operator) {
            case 'gt': return actualValue > rule.value;
            case 'lt': return actualValue < rule.value;
            case 'eq': return actualValue === rule.value;
            case 'gte': return actualValue >= rule.value;
            case 'lte': return actualValue <= rule.value;
            default: return false;
        }
    }

    private async cleanup(): Promise<void> {
        console.log('[LOAD TESTER] Cleaning up workers...');
        
        const killPromises = this.workers.map(worker => {
            return new Promise<void>((resolve) => {
                worker.once('exit', () => resolve());
                worker.kill('SIGTERM');
                
                // Force kill after 5 seconds
                setTimeout(() => {
                    if (!worker.isDead()) {
                        worker.kill('SIGKILL');
                        resolve();
                    }
                }, 5000);
            });
        });

        await Promise.all(killPromises);
        this.workers = [];
    }

    private logResults(result: LoadTestResult): void {
        console.log('\n=== LOAD TEST RESULTS ===');
        console.log(`Test: ${result.testName}`);
        console.log(`Duration: ${result.duration.toFixed(2)}s`);
        console.log(`Total Requests: ${result.totalRequests.toLocaleString()}`);
        console.log(`Successful: ${result.successfulRequests.toLocaleString()} (${((result.successfulRequests / result.totalRequests) * 100).toFixed(2)}%)`);
        console.log(`Failed: ${result.failedRequests.toLocaleString()} (${result.errorRate.toFixed(2)}%)`);
        console.log(`Throughput: ${result.throughput.toFixed(2)} req/s`);
        console.log(`Response Times:`);
        console.log(`  Average: ${result.averageResponseTime.toFixed(2)}ms`);
        console.log(`  95th percentile: ${result.p95ResponseTime.toFixed(2)}ms`);
        console.log(`  99th percentile: ${result.p99ResponseTime.toFixed(2)}ms`);
        console.log(`  Max: ${result.maxResponseTime.toFixed(2)}ms`);
        console.log(`Memory:`);
        console.log(`  Peak Heap: ${(result.memoryUsage.peakHeapUsed / 1024 / 1024).toFixed(2)}MB`);
        console.log(`  Peak RSS: ${(result.memoryUsage.peakRSS / 1024 / 1024).toFixed(2)}MB`);
        console.log(`CPU:`);
        console.log(`  Peak Usage: ${result.cpuUsage.peakCpuUsage.toFixed(2)}`);
        console.log(`  Average Usage: ${result.cpuUsage.averageCpuUsage.toFixed(2)}`);
        console.log('========================\n');
    }

    public getResults(): LoadTestResult[] {
        return [...this.results];
    }

    public exportResults(filename?: string): string {
        const fs = require('fs');
        const path = require('path');
        
        const exportFile = filename || `load-test-results-${Date.now()}.json`;
        const exportPath = path.join(process.cwd(), 'monitoring', 'load_test_results', exportFile);
        
        // Ensure directory exists
        const dir = path.dirname(exportPath);
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }

        fs.writeFileSync(exportPath, JSON.stringify(this.results, null, 2));
        console.log(`[LOAD TESTER] Results exported: ${exportPath}`);
        
        return exportPath;
    }
}

// Predefined load test configurations
export const LoadTestConfigs = {
    // Light load test for development
    development: {
        name: 'Development Load Test',
        duration: 60,
        concurrency: 5,
        rampUpTime: 10,
        targetTPS: 10,
        dataFrequency: 1,
        scenarios: [
            {
                name: 'Basic Trading Operations',
                weight: 100,
                actions: [
                    { type: 'market_data', params: { symbol: 'BTCUSDT' } },
                    { type: 'portfolio_check', params: {} },
                    { type: 'strategy_signal', params: { strategy: 'AdvancedAdaptive' } }
                ],
                validation: [
                    { metric: 'errorRate', operator: 'lt', value: 5, severity: 'error' },
                    { metric: 'averageResponseTime', operator: 'lt', value: 100, severity: 'warning' }
                ]
            }
        ]
    } as LoadTestConfig,

    // Production-like load test
    production: {
        name: 'Production Load Test',
        duration: 300,
        concurrency: 50,
        rampUpTime: 60,
        targetTPS: 100,
        dataFrequency: 10,
        scenarios: [
            {
                name: 'High Frequency Trading',
                weight: 70,
                actions: [
                    { type: 'market_data', params: { symbol: 'BTCUSDT' } },
                    { type: 'strategy_signal', params: { strategy: 'AdvancedAdaptive' } },
                    { type: 'place_order', params: { type: 'market', side: 'buy' } }
                ],
                validation: [
                    { metric: 'errorRate', operator: 'lt', value: 1, severity: 'error' },
                    { metric: 'averageResponseTime', operator: 'lt', value: 50, severity: 'error' },
                    { metric: 'throughput', operator: 'gt', value: 80, severity: 'warning' }
                ]
            },
            {
                name: 'Portfolio Management',
                weight: 30,
                actions: [
                    { type: 'portfolio_check', params: {} },
                    { type: 'cancel_order', params: { orderId: 'test' } }
                ],
                validation: [
                    { metric: 'errorRate', operator: 'lt', value: 2, severity: 'warning' }
                ]
            }
        ]
    } as LoadTestConfig,

    // Stress test to find breaking point
    stress: {
        name: 'Stress Test',
        duration: 600,
        concurrency: 200,
        rampUpTime: 120,
        targetTPS: 500,
        dataFrequency: 50,
        scenarios: [
            {
                name: 'Maximum Load Scenario',
                weight: 100,
                actions: [
                    { type: 'market_data', params: { symbol: 'BTCUSDT' } },
                    { type: 'strategy_signal', params: { strategy: 'AdvancedAdaptive' } },
                    { type: 'portfolio_check', params: {} },
                    { type: 'place_order', params: { type: 'limit', side: 'buy' } }
                ],
                validation: [
                    { metric: 'errorRate', operator: 'lt', value: 10, severity: 'warning' },
                    { metric: 'averageResponseTime', operator: 'lt', value: 200, severity: 'warning' },
                    { metric: 'peakMemory', operator: 'lt', value: 2000000000, severity: 'error' } // 2GB
                ]
            }
        ]
    } as LoadTestConfig
};
