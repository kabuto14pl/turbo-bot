/**
 * PHASE C.4 - Portfolio Rebalancing Automation
 * Intelligent Portfolio Management & Allocation
 * 
 * Implements advanced portfolio rebalancing with:
 * - Target allocation management
 * - Drift detection and monitoring
 * - Automated rebalancing execution
 * - Risk-adjusted allocation optimization
 * - Tax-efficient rebalancing
 * - Multi-strategy coordination
 * - Performance attribution analysis
 * 
 * Features:
 * - Dynamic allocation targets
 * - Threshold-based rebalancing
 * - Calendar-based rebalancing
 * - Volatility-based adjustments
 * - Correlation-aware rebalancing
 * - Transaction cost optimization
 * - Regulatory compliance
 */

import { EventEmitter } from 'events';
import { TradingPosition, Portfolio, TradingOrder } from './ProductionTradingEngine';
import { VaRResult, RiskMetrics } from './RealTimeVaRMonitor';

interface AllocationTarget {
    symbol: string;
    targetWeight: number; // 0.0 to 1.0
    minWeight: number;
    maxWeight: number;
    strategyId: string;
    priority: 'HIGH' | 'MEDIUM' | 'LOW';
    lastUpdated: Date;
    isActive: boolean;
}

interface AllocationDrift {
    symbol: string;
    currentWeight: number;
    targetWeight: number;
    drift: number; // percentage points
    driftPct: number; // percentage of target
    severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
    requiresRebalancing: boolean;
}

interface RebalancingConfig {
    driftThreshold: number; // percentage points (e.g., 0.05 = 5%)
    driftThresholdPct: number; // percentage of target (e.g., 0.20 = 20%)
    minRebalanceInterval: number; // milliseconds
    maxTransactionCost: number; // percentage of portfolio
    maxSingleTradeSize: number; // dollar amount
    enableTaxOptimization: boolean;
    enableCorrelationAdjustment: boolean;
    riskAdjustmentFactor: number; // 0.0 to 1.0
    emergencyRebalanceThreshold: number; // percentage points
}

interface RebalancingEvent {
    id: string;
    timestamp: Date;
    triggerType: 'DRIFT' | 'CALENDAR' | 'RISK' | 'MANUAL' | 'EMERGENCY';
    drifts: AllocationDrift[];
    plannedTrades: RebalancingTrade[];
    actualTrades: RebalancingTrade[];
    transactionCosts: number;
    executionTime: number;
    status: 'PLANNED' | 'EXECUTING' | 'COMPLETED' | 'FAILED' | 'CANCELLED';
    performance: RebalancingPerformance;
}

interface RebalancingTrade {
    id: string;
    symbol: string;
    action: 'BUY' | 'SELL';
    targetQuantity: number;
    actualQuantity?: number;
    estimatedPrice: number;
    actualPrice?: number;
    estimatedCost: number;
    actualCost?: number;
    priority: number;
    status: 'PENDING' | 'EXECUTING' | 'COMPLETED' | 'FAILED';
    reason: string;
}

interface RebalancingPerformance {
    portfolioValueBefore: number;
    portfolioValueAfter: number;
    totalTransactionCosts: number;
    driftReduction: number;
    riskReduction: number;
    trackingErrorImprovement: number;
    taxImpact: number;
    executionQuality: number; // 0-100 score
}

interface RiskAdjustment {
    symbol: string;
    originalTarget: number;
    adjustedTarget: number;
    adjustment: number;
    reason: 'VOLATILITY' | 'CORRELATION' | 'VAR' | 'CONCENTRATION' | 'LIQUIDITY';
    confidence: number;
}

interface TaxOptimization {
    symbol: string;
    harvestableLoss: number;
    taxSavings: number;
    washSaleRisk: boolean;
    holdingPeriod: number;
    recommendedAction: 'HARVEST' | 'DEFER' | 'PARTIAL';
}

interface CorrelationAnalysis {
    correlationMatrix: number[][];
    symbols: string[];
    averageCorrelation: number;
    maxCorrelation: number;
    diversificationRatio: number;
    recommendedAdjustments: Map<string, number>;
}

interface RebalancingMetrics {
    totalRebalances: number;
    averageDriftReduction: number;
    averageTransactionCost: number;
    averageExecutionTime: number;
    successRate: number;
    riskAdjustedReturn: number;
    trackingError: number;
    informationRatio: number;
    taxEfficiency: number;
}

/**
 * Portfolio Rebalancing Automation System
 * 
 * Advanced portfolio management system with intelligent rebalancing,
 * risk optimization, and automated execution
 */
export class PortfolioRebalancingSystem extends EventEmitter {
    private portfolio: Portfolio;
    private allocationTargets: Map<string, AllocationTarget> = new Map();
    private config: RebalancingConfig;
    private rebalancingHistory: RebalancingEvent[] = [];
    private lastRebalanceTime: Date = new Date(0);
    private currentRebalancing?: RebalancingEvent;
    
    // Risk and market data
    private lastVaRAssessment?: VaRResult;
    private riskMetrics?: RiskMetrics;
    private correlationMatrix: number[][] = [];
    private volatilities: Map<string, number> = new Map();
    
    // Monitoring
    private monitoringInterval?: NodeJS.Timeout;
    private isMonitoring: boolean = false;
    private metrics: RebalancingMetrics;

    constructor(portfolio: Portfolio, config?: Partial<RebalancingConfig>) {
        super();
        this.portfolio = portfolio;
        this.config = this.initializeConfig(config);
        this.metrics = this.initializeMetrics();
        this.setupEventHandlers();
    }

    /**
     * Start automatic rebalancing monitoring
     */
    public startMonitoring(intervalMs: number = 60000): void {
        if (this.isMonitoring) {
            console.log('‚ö†Ô∏è Portfolio rebalancing monitoring already active');
            return;
        }

        console.log('‚öñÔ∏è Starting Portfolio Rebalancing monitoring...');

        this.monitoringInterval = setInterval(async () => {
            await this.performRebalancingCheck();
        }, intervalMs);

        this.isMonitoring = true;
        this.emit('monitoringStarted');
        console.log('‚úÖ Portfolio rebalancing monitoring active');
    }

    /**
     * Stop monitoring
     */
    public stopMonitoring(): void {
        if (this.monitoringInterval) {
            clearInterval(this.monitoringInterval);
            this.monitoringInterval = undefined;
        }

        this.isMonitoring = false;
        this.emit('monitoringStopped');
        console.log('üõë Portfolio rebalancing monitoring stopped');
    }

    /**
     * Set target allocations
     */
    public setTargetAllocations(targets: Omit<AllocationTarget, 'lastUpdated' | 'isActive'>[]): void {
        console.log('üéØ Setting target allocations...');

        // Validate targets sum to 1.0
        const totalWeight = targets.reduce((sum, target) => sum + target.targetWeight, 0);
        if (Math.abs(totalWeight - 1.0) > 0.001) {
            throw new Error(`Target weights must sum to 1.0, got ${totalWeight.toFixed(3)}`);
        }

        // Clear existing targets
        this.allocationTargets.clear();

        // Set new targets
        for (const target of targets) {
            this.allocationTargets.set(target.symbol, {
                ...target,
                lastUpdated: new Date(),
                isActive: true
            });
        }

        this.emit('targetsUpdated', Array.from(this.allocationTargets.values()));
        console.log(`‚úÖ Set ${targets.length} allocation targets`);
    }

    /**
     * Analyze current allocation drift
     */
    public analyzeAllocationDrift(): AllocationDrift[] {
        const drifts: AllocationDrift[] = [];
        const totalPortfolioValue = this.portfolio.totalValue;

        for (const [symbol, target] of this.allocationTargets) {
            const position = this.portfolio.positions.find(p => p.symbol === symbol);
            const currentValue = position ? Math.abs(position.size) * position.currentPrice : 0;
            const currentWeight = currentValue / totalPortfolioValue;
            
            const drift = currentWeight - target.targetWeight;
            const driftPct = target.targetWeight !== 0 ? (drift / target.targetWeight) * 100 : 0;
            
            let severity: AllocationDrift['severity'] = 'LOW';
            let requiresRebalancing = false;

            if (Math.abs(drift) >= this.config.emergencyRebalanceThreshold) {
                severity = 'CRITICAL';
                requiresRebalancing = true;
            } else if (Math.abs(drift) >= this.config.driftThreshold || Math.abs(driftPct) >= this.config.driftThresholdPct * 100) {
                severity = Math.abs(drift) >= this.config.driftThreshold * 2 ? 'HIGH' : 'MEDIUM';
                requiresRebalancing = true;
            }

            drifts.push({
                symbol,
                currentWeight,
                targetWeight: target.targetWeight,
                drift,
                driftPct,
                severity,
                requiresRebalancing
            });
        }

        return drifts.sort((a, b) => Math.abs(b.drift) - Math.abs(a.drift));
    }

    /**
     * Execute manual rebalancing
     */
    public async executeRebalancing(reason: string = 'Manual rebalancing'): Promise<RebalancingEvent> {
        if (this.currentRebalancing && this.currentRebalancing.status === 'EXECUTING') {
            throw new Error('Rebalancing already in progress');
        }

        console.log('‚öñÔ∏è Executing portfolio rebalancing...');

        const drifts = this.analyzeAllocationDrift();
        const trades = await this.planRebalancingTrades(drifts);
        
        const rebalancingEvent: RebalancingEvent = {
            id: `rebal_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            timestamp: new Date(),
            triggerType: 'MANUAL',
            drifts,
            plannedTrades: trades,
            actualTrades: [],
            transactionCosts: 0,
            executionTime: 0,
            status: 'PLANNED',
            performance: this.initializePerformance()
        };

        this.currentRebalancing = rebalancingEvent;
        
        try {
            await this.executeRebalancingTrades(rebalancingEvent);
            rebalancingEvent.status = 'COMPLETED';
            this.lastRebalanceTime = new Date();
            
            console.log(`‚úÖ Rebalancing completed: ${trades.length} trades executed`);
            this.emit('rebalancingCompleted', rebalancingEvent);
            
        } catch (error) {
            rebalancingEvent.status = 'FAILED';
            console.error('‚ùå Rebalancing failed:', error);
            this.emit('rebalancingFailed', { event: rebalancingEvent, error });
        } finally {
            this.recordRebalancingEvent(rebalancingEvent);
            this.currentRebalancing = undefined;
        }

        return rebalancingEvent;
    }

    /**
     * Optimize allocations based on risk metrics
     */
    public async optimizeAllocations(riskMetrics: RiskMetrics, varResult: VaRResult): Promise<RiskAdjustment[]> {
        console.log('üî¨ Optimizing allocations based on risk metrics...');

        this.lastVaRAssessment = varResult;
        this.riskMetrics = riskMetrics;
        
        const adjustments: RiskAdjustment[] = [];
        const riskFactor = this.config.riskAdjustmentFactor;

        for (const [symbol, target] of this.allocationTargets) {
            let adjustedTarget = target.targetWeight;
            let totalAdjustment = 0;
            const reasons: string[] = [];

            // Volatility adjustment
            const volatility = this.volatilities.get(symbol) || 0.20;
            if (volatility > 0.30) { // High volatility
                const volAdjustment = -riskFactor * 0.02; // Reduce by up to 2%
                adjustedTarget += volAdjustment;
                totalAdjustment += volAdjustment;
                reasons.push('VOLATILITY');
            }

            // VaR contribution adjustment
            const varContribution = varResult.positions.find(p => p.symbol === symbol);
            if (varContribution && varContribution.contributionPct > 40) { // High VaR contribution
                const varAdjustment = -riskFactor * 0.03; // Reduce by up to 3%
                adjustedTarget += varAdjustment;
                totalAdjustment += varAdjustment;
                reasons.push('VAR');
            }

            // Concentration check
            if (target.targetWeight > 0.30) { // High concentration
                const concentrationAdjustment = -riskFactor * 0.01; // Reduce by up to 1%
                adjustedTarget += concentrationAdjustment;
                totalAdjustment += concentrationAdjustment;
                reasons.push('CONCENTRATION');
            }

            // Ensure within bounds
            adjustedTarget = Math.max(target.minWeight, Math.min(target.maxWeight, adjustedTarget));

            if (Math.abs(totalAdjustment) > 0.001) {
                adjustments.push({
                    symbol,
                    originalTarget: target.targetWeight,
                    adjustedTarget,
                    adjustment: totalAdjustment,
                    reason: reasons[0] as any || 'VOLATILITY',
                    confidence: this.calculateAdjustmentConfidence(symbol, reasons)
                });
            }
        }

        // Normalize adjustments to sum to 1.0
        this.normalizeAdjustments(adjustments);

        if (adjustments.length > 0) {
            console.log(`üìä Generated ${adjustments.length} risk-based allocation adjustments`);
            this.emit('allocationsOptimized', adjustments);
        }

        return adjustments;
    }

    /**
     * Analyze tax optimization opportunities
     */
    public analyzeTaxOptimization(): TaxOptimization[] {
        const optimizations: TaxOptimization[] = [];

        for (const position of this.portfolio.positions) {
            if (position.unrealizedPnL < 0) { // Loss position
                const harvestableLoss = Math.abs(position.unrealizedPnL);
                const taxSavings = harvestableLoss * 0.25; // Assume 25% tax rate
                const holdingPeriod = this.calculateHoldingPeriod(position);
                
                optimizations.push({
                    symbol: position.symbol,
                    harvestableLoss,
                    taxSavings,
                    washSaleRisk: holdingPeriod < 30, // 30-day wash sale rule
                    holdingPeriod,
                    recommendedAction: this.getRecommendedTaxAction(harvestableLoss, holdingPeriod)
                });
            }
        }

        return optimizations.sort((a, b) => b.taxSavings - a.taxSavings);
    }

    /**
     * Perform correlation analysis and recommendations
     */
    public performCorrelationAnalysis(): CorrelationAnalysis {
        const symbols = Array.from(this.allocationTargets.keys());
        const correlationMatrix = this.buildCorrelationMatrix(symbols);
        
        let totalCorrelation = 0;
        let count = 0;
        let maxCorrelation = 0;

        for (let i = 0; i < symbols.length; i++) {
            for (let j = i + 1; j < symbols.length; j++) {
                const correlation = Math.abs(correlationMatrix[i][j]);
                totalCorrelation += correlation;
                maxCorrelation = Math.max(maxCorrelation, correlation);
                count++;
            }
        }

        const averageCorrelation = count > 0 ? totalCorrelation / count : 0;
        const diversificationRatio = this.calculateDiversificationRatio(correlationMatrix, symbols);
        
        const recommendedAdjustments = new Map<string, number>();
        
        // Identify highly correlated pairs and recommend adjustments
        for (let i = 0; i < symbols.length; i++) {
            for (let j = i + 1; j < symbols.length; j++) {
                if (Math.abs(correlationMatrix[i][j]) > 0.80) { // High correlation
                    const symbol1 = symbols[i];
                    const symbol2 = symbols[j];
                    const target1 = this.allocationTargets.get(symbol1)!;
                    const target2 = this.allocationTargets.get(symbol2)!;
                    
                    // Recommend reducing allocation to smaller position
                    if (target1.targetWeight < target2.targetWeight) {
                        recommendedAdjustments.set(symbol1, target1.targetWeight * 0.8);
                    } else {
                        recommendedAdjustments.set(symbol2, target2.targetWeight * 0.8);
                    }
                }
            }
        }

        return {
            correlationMatrix,
            symbols,
            averageCorrelation,
            maxCorrelation,
            diversificationRatio,
            recommendedAdjustments
        };
    }

    /**
     * Get rebalancing metrics
     */
    public getRebalancingMetrics(): RebalancingMetrics {
        return { ...this.metrics };
    }

    /**
     * Get rebalancing history
     */
    public getRebalancingHistory(limit: number = 50): RebalancingEvent[] {
        return this.rebalancingHistory.slice(-limit);
    }

    /**
     * Update portfolio
     */
    public updatePortfolio(portfolio: Portfolio): void {
        this.portfolio = portfolio;
    }

    /**
     * Update market data
     */
    public updateMarketData(symbol: string, price: number, volatility: number): void {
        this.volatilities.set(symbol, volatility);
        
        // Update position current prices
        const position = this.portfolio.positions.find(p => p.symbol === symbol);
        if (position) {
            position.currentPrice = price;
            position.unrealizedPnL = position.size * (price - position.entryPrice);
        }
    }

    // Private Methods

    private initializeConfig(config?: Partial<RebalancingConfig>): RebalancingConfig {
        return {
            driftThreshold: 0.05, // 5%
            driftThresholdPct: 0.20, // 20% of target
            minRebalanceInterval: 3600000, // 1 hour
            maxTransactionCost: 0.005, // 0.5% of portfolio
            maxSingleTradeSize: 10000, // $10k
            enableTaxOptimization: true,
            enableCorrelationAdjustment: true,
            riskAdjustmentFactor: 0.5,
            emergencyRebalanceThreshold: 0.15, // 15%
            ...config
        };
    }

    private initializeMetrics(): RebalancingMetrics {
        return {
            totalRebalances: 0,
            averageDriftReduction: 0,
            averageTransactionCost: 0,
            averageExecutionTime: 0,
            successRate: 0,
            riskAdjustedReturn: 0,
            trackingError: 0,
            informationRatio: 0,
            taxEfficiency: 0
        };
    }

    private initializePerformance(): RebalancingPerformance {
        return {
            portfolioValueBefore: this.portfolio.totalValue,
            portfolioValueAfter: 0,
            totalTransactionCosts: 0,
            driftReduction: 0,
            riskReduction: 0,
            trackingErrorImprovement: 0,
            taxImpact: 0,
            executionQuality: 0
        };
    }

    private setupEventHandlers(): void {
        this.on('rebalancingCompleted', this.updateMetrics.bind(this));
        this.on('driftDetected', this.handleDriftDetected.bind(this));
    }

    private async performRebalancingCheck(): Promise<void> {
        try {
            const timeSinceLastRebalance = Date.now() - this.lastRebalanceTime.getTime();
            
            // Skip if minimum interval not elapsed
            if (timeSinceLastRebalance < this.config.minRebalanceInterval) {
                return;
            }

            const drifts = this.analyzeAllocationDrift();
            const significantDrifts = drifts.filter(d => d.requiresRebalancing);

            if (significantDrifts.length > 0) {
                console.log(`üìä Detected ${significantDrifts.length} significant allocation drifts`);
                this.emit('driftDetected', significantDrifts);

                // Check for emergency rebalancing
                const criticalDrifts = significantDrifts.filter(d => d.severity === 'CRITICAL');
                if (criticalDrifts.length > 0) {
                    console.log('üö® Critical drift detected - triggering emergency rebalancing');
                    await this.executeRebalancing('Emergency rebalancing - critical drift detected');
                }
                // Auto-rebalance for high drifts
                else if (significantDrifts.some(d => d.severity === 'HIGH')) {
                    console.log('‚ö†Ô∏è High drift detected - triggering automatic rebalancing');
                    await this.executeRebalancing('Automatic rebalancing - high drift detected');
                }
            }

        } catch (error) {
            console.error('Rebalancing check failed:', error);
            this.emit('rebalancingError', error);
        }
    }

    private async planRebalancingTrades(drifts: AllocationDrift[]): Promise<RebalancingTrade[]> {
        const trades: RebalancingTrade[] = [];
        const totalPortfolioValue = this.portfolio.totalValue;
        let tradeId = 0;

        for (const drift of drifts) {
            if (!drift.requiresRebalancing) continue;

            const target = this.allocationTargets.get(drift.symbol);
            if (!target) continue;

            const targetValue = totalPortfolioValue * target.targetWeight;
            const currentValue = totalPortfolioValue * drift.currentWeight;
            const tradeValue = targetValue - currentValue;
            
            if (Math.abs(tradeValue) < 10) continue; // Skip tiny trades

            const position = this.portfolio.positions.find(p => p.symbol === drift.symbol);
            const currentPrice = position?.currentPrice || 100; // Default price if no position
            
            const targetQuantity = Math.abs(tradeValue) / currentPrice;
            const action: 'BUY' | 'SELL' = tradeValue > 0 ? 'BUY' : 'SELL';
            
            // Apply single trade size limit
            const maxQuantity = this.config.maxSingleTradeSize / currentPrice;
            const limitedQuantity = Math.min(targetQuantity, maxQuantity);

            const estimatedCost = this.estimateTransactionCost(limitedQuantity, currentPrice);

            trades.push({
                id: `trade_${++tradeId}`,
                symbol: drift.symbol,
                action,
                targetQuantity: limitedQuantity,
                estimatedPrice: currentPrice,
                estimatedCost,
                priority: this.calculateTradePriority(drift, target),
                status: 'PENDING',
                reason: `Rebalance ${drift.symbol}: ${drift.drift > 0 ? 'overweight' : 'underweight'} by ${Math.abs(drift.drift * 100).toFixed(1)}%`
            });
        }

        // Sort by priority and validate total cost
        trades.sort((a, b) => b.priority - a.priority);
        
        const totalEstimatedCost = trades.reduce((sum, trade) => sum + trade.estimatedCost, 0);
        const costPct = totalEstimatedCost / totalPortfolioValue;
        
        if (costPct > this.config.maxTransactionCost) {
            // Remove lowest priority trades to stay within cost limit
            let runningCost = 0;
            const filteredTrades = [];
            
            for (const trade of trades) {
                if ((runningCost + trade.estimatedCost) / totalPortfolioValue <= this.config.maxTransactionCost) {
                    filteredTrades.push(trade);
                    runningCost += trade.estimatedCost;
                } else {
                    break;
                }
            }
            
            console.log(`üí∞ Filtered trades: ${trades.length} -> ${filteredTrades.length} to stay within cost limit`);
            return filteredTrades;
        }

        return trades;
    }

    private async executeRebalancingTrades(rebalancingEvent: RebalancingEvent): Promise<void> {
        rebalancingEvent.status = 'EXECUTING';
        const startTime = Date.now();
        
        console.log(`‚ö° Executing ${rebalancingEvent.plannedTrades.length} rebalancing trades...`);

        for (const trade of rebalancingEvent.plannedTrades) {
            try {
                trade.status = 'EXECUTING';
                
                // Simulate trade execution
                const executedTrade = await this.executeTrade(trade);
                rebalancingEvent.actualTrades.push(executedTrade);
                
                trade.status = 'COMPLETED';
                trade.actualQuantity = executedTrade.actualQuantity;
                trade.actualPrice = executedTrade.actualPrice;
                trade.actualCost = executedTrade.actualCost;
                
                rebalancingEvent.transactionCosts += executedTrade.actualCost || 0;
                
                console.log(`‚úÖ Trade completed: ${trade.action} ${trade.actualQuantity} ${trade.symbol} @ $${trade.actualPrice?.toFixed(2)}`);
                
            } catch (error) {
                trade.status = 'FAILED';
                console.error(`‚ùå Trade failed: ${trade.symbol}`, error);
                this.emit('tradeFailed', { trade, error });
            }
        }

        rebalancingEvent.executionTime = Date.now() - startTime;
        rebalancingEvent.performance = this.calculateRebalancingPerformance(rebalancingEvent);
        
        console.log(`üìä Rebalancing execution completed in ${rebalancingEvent.executionTime}ms`);
        console.log(`üí∞ Total transaction costs: $${rebalancingEvent.transactionCosts.toFixed(2)}`);
    }

    private async executeTrade(trade: RebalancingTrade): Promise<RebalancingTrade> {
        // Simulate trade execution with slippage
        const slippage = 0.001; // 0.1% slippage
        const actualPrice = trade.estimatedPrice * (1 + (trade.action === 'BUY' ? slippage : -slippage));
        const actualQuantity = trade.targetQuantity;
        const actualCost = this.estimateTransactionCost(actualQuantity, actualPrice);

        // Update portfolio position
        this.updatePortfolioFromTrade(trade.symbol, trade.action, actualQuantity, actualPrice);

        return {
            ...trade,
            actualQuantity,
            actualPrice,
            actualCost,
            status: 'COMPLETED'
        };
    }

    private updatePortfolioFromTrade(symbol: string, action: 'BUY' | 'SELL', quantity: number, price: number): void {
        let position = this.portfolio.positions.find(p => p.symbol === symbol);
        
        if (!position) {
            // Create new position
            position = {
                id: `pos_${Date.now()}_${symbol}`,
                symbol,
                size: action === 'BUY' ? quantity : -quantity,
                entryPrice: price,
                currentPrice: price,
                unrealizedPnL: 0,
                timestamp: new Date(),
                strategyId: 'rebalancing',
                type: action === 'BUY' ? 'LONG' : 'SHORT'
            };
            this.portfolio.positions.push(position);
        } else {
            // Update existing position
            if (action === 'BUY') {
                const totalValue = position.size * position.entryPrice + quantity * price;
                const totalSize = position.size + quantity;
                position.entryPrice = totalSize !== 0 ? totalValue / totalSize : price;
                position.size = totalSize;
            } else {
                position.size -= quantity;
                if (position.size === 0) {
                    // Remove position if fully closed
                    const index = this.portfolio.positions.indexOf(position);
                    this.portfolio.positions.splice(index, 1);
                }
            }
        }

        // Update portfolio cash
        const tradeValue = quantity * price;
        if (action === 'BUY') {
            this.portfolio.cash -= tradeValue;
        } else {
            this.portfolio.cash += tradeValue;
        }

        // Update portfolio total value
        this.portfolio.totalValue = this.portfolio.cash + 
            this.portfolio.positions.reduce((sum, p) => sum + Math.abs(p.size) * p.currentPrice, 0);
    }

    private estimateTransactionCost(quantity: number, price: number): number {
        const tradeValue = quantity * price;
        const commissionRate = 0.001; // 0.1% commission
        const bidAskSpread = 0.0005; // 0.05% spread
        
        return tradeValue * (commissionRate + bidAskSpread);
    }

    private calculateTradePriority(drift: AllocationDrift, target: AllocationTarget): number {
        let priority = Math.abs(drift.drift) * 100; // Base on drift magnitude
        
        // Adjust for target priority
        switch (target.priority) {
            case 'HIGH': priority *= 1.5; break;
            case 'MEDIUM': priority *= 1.0; break;
            case 'LOW': priority *= 0.5; break;
        }
        
        // Adjust for severity
        switch (drift.severity) {
            case 'CRITICAL': priority *= 2.0; break;
            case 'HIGH': priority *= 1.5; break;
            case 'MEDIUM': priority *= 1.0; break;
            case 'LOW': priority *= 0.5; break;
        }
        
        return priority;
    }

    private calculateRebalancingPerformance(event: RebalancingEvent): RebalancingPerformance {
        const performance = event.performance;
        performance.portfolioValueAfter = this.portfolio.totalValue;
        
        // Calculate drift reduction
        const beforeDrifts = event.drifts;
        const afterDrifts = this.analyzeAllocationDrift();
        
        const beforeTotalDrift = beforeDrifts.reduce((sum, d) => sum + Math.abs(d.drift), 0);
        const afterTotalDrift = afterDrifts.reduce((sum, d) => sum + Math.abs(d.drift), 0);
        
        performance.driftReduction = beforeTotalDrift - afterTotalDrift;
        
        // Calculate execution quality
        const plannedCost = event.plannedTrades.reduce((sum, t) => sum + t.estimatedCost, 0);
        const actualCost = event.transactionCosts;
        performance.executionQuality = plannedCost > 0 ? Math.max(0, 100 - ((actualCost - plannedCost) / plannedCost * 100)) : 100;
        
        return performance;
    }

    private recordRebalancingEvent(event: RebalancingEvent): void {
        this.rebalancingHistory.push(event);
        
        // Keep only last 100 events
        if (this.rebalancingHistory.length > 100) {
            this.rebalancingHistory = this.rebalancingHistory.slice(-100);
        }
    }

    private calculateAdjustmentConfidence(symbol: string, reasons: string[]): number {
        let confidence = 0.5; // Base confidence
        
        // Higher confidence for multiple reasons
        confidence += reasons.length * 0.1;
        
        // Higher confidence for volatility-based adjustments
        if (reasons.includes('VOLATILITY')) confidence += 0.2;
        if (reasons.includes('VAR')) confidence += 0.2;
        if (reasons.includes('CONCENTRATION')) confidence += 0.1;
        
        return Math.min(1.0, confidence);
    }

    private normalizeAdjustments(adjustments: RiskAdjustment[]): void {
        if (adjustments.length === 0) return;
        
        const totalAdjustment = adjustments.reduce((sum, adj) => sum + adj.adjustment, 0);
        
        if (Math.abs(totalAdjustment) > 0.001) {
            // Distribute the excess/deficit proportionally
            const factor = -totalAdjustment / adjustments.length;
            for (const adjustment of adjustments) {
                adjustment.adjustedTarget += factor;
                adjustment.adjustment += factor;
            }
        }
    }

    private calculateHoldingPeriod(position: TradingPosition): number {
        return Math.floor((Date.now() - position.timestamp.getTime()) / (1000 * 60 * 60 * 24));
    }

    private getRecommendedTaxAction(loss: number, holdingPeriod: number): TaxOptimization['recommendedAction'] {
        if (holdingPeriod < 30) return 'DEFER'; // Avoid wash sale
        if (loss > 10000) return 'HARVEST'; // Large loss
        if (loss > 1000) return 'PARTIAL'; // Medium loss
        return 'DEFER'; // Small loss
    }

    private buildCorrelationMatrix(symbols: string[]): number[][] {
        const matrix: number[][] = [];
        
        for (let i = 0; i < symbols.length; i++) {
            matrix[i] = [];
            for (let j = 0; j < symbols.length; j++) {
                if (i === j) {
                    matrix[i][j] = 1.0;
                } else {
                    // Simulate correlation (in production, use historical data)
                    matrix[i][j] = 0.3 + Math.random() * 0.5; // 0.3 to 0.8 correlation
                }
            }
        }
        
        return matrix;
    }

    private calculateDiversificationRatio(correlationMatrix: number[][], symbols: string[]): number {
        // Simplified diversification ratio calculation
        const n = symbols.length;
        if (n <= 1) return 1.0;
        
        let avgCorrelation = 0;
        let count = 0;
        
        for (let i = 0; i < n; i++) {
            for (let j = i + 1; j < n; j++) {
                avgCorrelation += correlationMatrix[i][j];
                count++;
            }
        }
        
        avgCorrelation = count > 0 ? avgCorrelation / count : 0;
        return 1 / (1 + (n - 1) * avgCorrelation);
    }

    private updateMetrics(event: RebalancingEvent): void {
        this.metrics.totalRebalances++;
        
        // Update running averages
        const newWeight = 1 / this.metrics.totalRebalances;
        const oldWeight = 1 - newWeight;
        
        this.metrics.averageDriftReduction = 
            oldWeight * this.metrics.averageDriftReduction + 
            newWeight * event.performance.driftReduction;
            
        this.metrics.averageTransactionCost = 
            oldWeight * this.metrics.averageTransactionCost + 
            newWeight * (event.transactionCosts / this.portfolio.totalValue * 100);
            
        this.metrics.averageExecutionTime = 
            oldWeight * this.metrics.averageExecutionTime + 
            newWeight * event.executionTime;
            
        // Update success rate
        const successfulRebalances = this.rebalancingHistory.filter(e => e.status === 'COMPLETED').length;
        this.metrics.successRate = (successfulRebalances / this.metrics.totalRebalances) * 100;
    }

    private handleDriftDetected(drifts: AllocationDrift[]): void {
        console.log(`üìä Allocation drift detected: ${drifts.length} assets out of target`);
        
        for (const drift of drifts) {
            if (drift.severity === 'CRITICAL') {
                console.log(`üö® CRITICAL: ${drift.symbol} drift: ${(drift.drift * 100).toFixed(1)}%`);
            }
        }
    }
}

export {
    AllocationTarget,
    AllocationDrift,
    RebalancingConfig,
    RebalancingEvent,
    RebalancingTrade,
    RebalancingPerformance,
    RiskAdjustment,
    TaxOptimization,
    CorrelationAnalysis,
    RebalancingMetrics
};
