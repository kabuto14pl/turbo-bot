"use strict";
/**
 * PHASE C.3 - Enterprise Monitoring & Alerting
 * Prometheus Metrics Exporter for Trading Bot
 *
 * Features:
 * - Real-time metrics collection from all system components
 * - Prometheus-compatible metric format
 * - Integration with Phase A cache and Phase B memory monitoring
 * - Trading-specific metrics (signals, strategies, performance)
 * - System health and resource monitoring
 * - Alert-ready metric thresholds
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultPrometheusConfig = exports.PrometheusMetricsExporter = void 0;
const events_1 = require("events");
const http = __importStar(require("http"));
const url = __importStar(require("url"));
class PrometheusMetricsExporter extends events_1.EventEmitter {
    constructor(port = 9090) {
        super();
        this.metrics = new Map();
        this.metricDefinitions = new Map();
        this.server = null;
        this.isRunning = false;
        this.collectInterval = null;
        this.startTime = Date.now();
        // Integrations
        this.realTimeEngine = null;
        this.strategyOrchestrator = null;
        this.cacheService = null;
        this.memoryOptimizer = null;
        // Alert system
        this.alertRules = [];
        this.activeAlerts = new Map();
        this.port = port;
        this.initializeMetricDefinitions();
        this.setupDefaultAlertRules();
        console.log('[PROMETHEUS EXPORTER] Metrics exporter initialized');
        console.log(`[PROMETHEUS EXPORTER] Will serve metrics on port ${this.port}`);
    }
    // ==================== INITIALIZATION ====================
    initializeMetricDefinitions() {
        const definitions = [
            // System Metrics
            { name: 'system_uptime_seconds', help: 'System uptime in seconds', type: 'counter' },
            { name: 'system_memory_usage_bytes', help: 'System memory usage in bytes', type: 'gauge' },
            { name: 'system_memory_total_bytes', help: 'Total system memory in bytes', type: 'gauge' },
            { name: 'system_cpu_usage_percent', help: 'System CPU usage percentage', type: 'gauge' },
            { name: 'system_disk_usage_percent', help: 'System disk usage percentage', type: 'gauge' },
            // Trading Engine Metrics
            { name: 'trading_signals_total', help: 'Total trading signals generated', type: 'counter', labelNames: ['strategy', 'action'] },
            { name: 'trading_signals_success_total', help: 'Total successful trading signals', type: 'counter', labelNames: ['strategy'] },
            { name: 'trading_signals_error_total', help: 'Total failed trading signals', type: 'counter', labelNames: ['strategy', 'error_type'] },
            { name: 'trading_strategies_active', help: 'Number of active trading strategies', type: 'gauge' },
            { name: 'trading_strategy_switches_total', help: 'Total strategy switches performed', type: 'counter' },
            { name: 'trading_signal_latency_ms', help: 'Trading signal processing latency in milliseconds', type: 'histogram' },
            // Market Data Metrics
            { name: 'market_data_messages_total', help: 'Total market data messages received', type: 'counter', labelNames: ['exchange', 'symbol'] },
            { name: 'market_data_uptime_percent', help: 'Market data uptime percentage', type: 'gauge', labelNames: ['exchange'] },
            { name: 'market_data_latency_ms', help: 'Market data latency in milliseconds', type: 'gauge', labelNames: ['exchange'] },
            { name: 'market_data_quality_score', help: 'Market data quality score (0-100)', type: 'gauge', labelNames: ['exchange'] },
            { name: 'market_data_cache_hit_ratio', help: 'Cache hit ratio for market data', type: 'gauge' },
            // Performance Metrics
            { name: 'orchestrator_memory_usage_bytes', help: 'Strategy orchestrator memory usage in bytes', type: 'gauge' },
            { name: 'orchestrator_signals_per_second', help: 'Signals processed per second by orchestrator', type: 'gauge' },
            { name: 'orchestrator_avg_latency_ms', help: 'Average orchestrator processing latency in milliseconds', type: 'gauge' },
            { name: 'orchestrator_error_rate_percent', help: 'Orchestrator error rate percentage', type: 'gauge' },
            // Alert Metrics
            { name: 'alerts_fired_total', help: 'Total alerts fired', type: 'counter', labelNames: ['severity', 'rule'] },
            { name: 'alerts_resolved_total', help: 'Total alerts resolved', type: 'counter', labelNames: ['severity', 'rule'] },
            { name: 'alerts_active', help: 'Number of active alerts', type: 'gauge', labelNames: ['severity'] }
        ];
        definitions.forEach(def => {
            this.metricDefinitions.set(def.name, def);
        });
    }
    setupDefaultAlertRules() {
        this.alertRules = [
            // Critical Alerts
            {
                name: 'system_memory_high',
                condition: 'system_memory_usage_bytes / system_memory_total_bytes > 0.9',
                threshold: 0.9,
                duration: 60,
                severity: 'critical',
                description: 'System memory usage is above 90%',
                enabled: true
            },
            {
                name: 'market_data_down',
                condition: 'market_data_uptime_percent < 95',
                threshold: 95,
                duration: 30,
                severity: 'critical',
                description: 'Market data uptime is below 95%',
                enabled: true
            },
            {
                name: 'trading_error_rate_high',
                condition: 'orchestrator_error_rate_percent > 10',
                threshold: 10,
                duration: 120,
                severity: 'critical',
                description: 'Trading error rate is above 10%',
                enabled: true
            },
            // Warning Alerts
            {
                name: 'signal_latency_high',
                condition: 'trading_signal_latency_ms > 1000',
                threshold: 1000,
                duration: 300,
                severity: 'warning',
                description: 'Trading signal latency is above 1000ms',
                enabled: true
            },
            {
                name: 'cache_hit_ratio_low',
                condition: 'market_data_cache_hit_ratio < 0.8',
                threshold: 0.8,
                duration: 300,
                severity: 'warning',
                description: 'Cache hit ratio is below 80%',
                enabled: true
            },
            // Info Alerts
            {
                name: 'strategy_switch_frequent',
                condition: 'rate(trading_strategy_switches_total[5m]) > 0.1',
                threshold: 0.1,
                duration: 300,
                severity: 'info',
                description: 'Strategy switching is happening frequently',
                enabled: true
            }
        ];
    }
    // ==================== INTEGRATION METHODS ====================
    integrateRealTimeEngine(engine) {
        this.realTimeEngine = engine;
        // Listen to engine events
        engine.on('marketData', (data) => {
            this.incrementMetric('market_data_messages_total', 1, {
                exchange: data.exchange,
                symbol: data.symbol
            });
            this.setMetric('market_data_latency_ms', data.latency || 0, {
                exchange: data.exchange
            });
            this.setMetric('market_data_quality_score', data.quality?.score || 0, {
                exchange: data.exchange
            });
        });
        engine.on('engineStats', (stats) => {
            this.setMetric('market_data_uptime_percent', stats.uptime || 0);
            this.setMetric('market_data_cache_hit_ratio', stats.cacheHitRatio || 0);
        });
        console.log('[PROMETHEUS EXPORTER] Real-time engine integration established');
    }
    integrateStrategyOrchestrator(orchestrator) {
        this.strategyOrchestrator = orchestrator;
        // Listen to orchestrator events
        orchestrator.on('signalGenerated', (signal) => {
            this.incrementMetric('trading_signals_total', 1, {
                strategy: signal.contributingStrategies?.join(',') || 'unknown',
                action: signal.finalAction
            });
        });
        orchestrator.on('strategySwitched', () => {
            this.incrementMetric('trading_strategy_switches_total', 1);
        });
        orchestrator.on('performanceUpdate', (performance) => {
            const stats = performance.stats;
            this.setMetric('orchestrator_memory_usage_bytes', stats.memoryUsage || 0);
            this.setMetric('orchestrator_signals_per_second', stats.signalsPerSecond || 0);
            this.setMetric('orchestrator_avg_latency_ms', stats.averageLatency || 0);
            this.setMetric('trading_strategies_active', performance.strategies?.length || 0);
            // Calculate error rate
            const totalSignals = stats.totalSignalsProcessed || 1;
            const errorRate = (stats.errors || 0) / totalSignals * 100;
            this.setMetric('orchestrator_error_rate_percent', errorRate);
        });
        orchestrator.on('error', () => {
            this.incrementMetric('trading_signals_error_total', 1, {
                strategy: 'unknown',
                error_type: 'orchestrator_error'
            });
        });
        console.log('[PROMETHEUS EXPORTER] Strategy orchestrator integration established');
    }
    integrateCacheService(cache) {
        this.cacheService = cache;
        console.log('[PROMETHEUS EXPORTER] Cache service integration established');
    }
    integrateMemoryOptimizer(optimizer) {
        this.memoryOptimizer = optimizer;
        console.log('[PROMETHEUS EXPORTER] Memory optimizer integration established');
    }
    // ==================== METRIC OPERATIONS ====================
    setMetric(name, value, labels) {
        const key = this.getMetricKey(name, labels);
        const definition = this.metricDefinitions.get(name);
        if (!definition) {
            console.warn(`[PROMETHEUS EXPORTER] Unknown metric: ${name}`);
            return;
        }
        this.metrics.set(key, {
            name,
            help: definition.help,
            type: definition.type,
            labels: labels || {},
            value,
            timestamp: Date.now()
        });
    }
    incrementMetric(name, increment = 1, labels) {
        const key = this.getMetricKey(name, labels);
        const existing = this.metrics.get(key);
        if (existing) {
            existing.value += increment;
            existing.timestamp = Date.now();
        }
        else {
            this.setMetric(name, increment, labels);
        }
    }
    getMetricKey(name, labels) {
        if (!labels)
            return name;
        const labelStr = Object.entries(labels)
            .sort(([a], [b]) => a.localeCompare(b))
            .map(([k, v]) => `${k}="${v}"`)
            .join(',');
        return `${name}{${labelStr}}`;
    }
    // ==================== SYSTEM METRICS COLLECTION ====================
    collectSystemMetrics() {
        const memUsage = process.memoryUsage();
        const uptime = (Date.now() - this.startTime) / 1000;
        // Basic system metrics
        this.setMetric('system_uptime_seconds', uptime);
        this.setMetric('system_memory_usage_bytes', memUsage.heapUsed);
        this.setMetric('system_memory_total_bytes', memUsage.heapTotal);
        // CPU usage (simplified)
        const cpuUsage = process.cpuUsage();
        const cpuPercent = (cpuUsage.user + cpuUsage.system) / 1000000 / uptime * 100;
        this.setMetric('system_cpu_usage_percent', Math.min(100, cpuPercent));
        // Disk usage (placeholder - would need additional library for real implementation)
        this.setMetric('system_disk_usage_percent', 45); // Mock value
    }
    // ==================== ALERT PROCESSING ====================
    processAlerts() {
        for (const rule of this.alertRules) {
            if (!rule.enabled)
                continue;
            const isTriggered = this.evaluateAlertRule(rule);
            const alertKey = rule.name;
            const existingAlert = this.activeAlerts.get(alertKey);
            if (isTriggered && !existingAlert) {
                // Fire new alert
                const alert = {
                    rule: rule.name,
                    severity: rule.severity,
                    description: rule.description,
                    firedAt: Date.now(),
                    value: this.getMetricValueForRule(rule)
                };
                this.activeAlerts.set(alertKey, alert);
                this.incrementMetric('alerts_fired_total', 1, {
                    severity: rule.severity,
                    rule: rule.name
                });
                this.emit('alertFired', alert);
                console.warn(`[PROMETHEUS EXPORTER] ðŸš¨ Alert fired: ${rule.name} - ${rule.description}`);
            }
            else if (!isTriggered && existingAlert) {
                // Resolve existing alert
                this.activeAlerts.delete(alertKey);
                this.incrementMetric('alerts_resolved_total', 1, {
                    severity: rule.severity,
                    rule: rule.name
                });
                this.emit('alertResolved', { ...existingAlert, resolvedAt: Date.now() });
                console.log(`[PROMETHEUS EXPORTER] âœ… Alert resolved: ${rule.name}`);
            }
        }
        // Update active alert counts
        const alertCounts = { critical: 0, warning: 0, info: 0 };
        for (const alert of this.activeAlerts.values()) {
            alertCounts[alert.severity]++;
        }
        this.setMetric('alerts_active', alertCounts.critical, { severity: 'critical' });
        this.setMetric('alerts_active', alertCounts.warning, { severity: 'warning' });
        this.setMetric('alerts_active', alertCounts.info, { severity: 'info' });
    }
    evaluateAlertRule(rule) {
        // Simplified rule evaluation - in production would use proper PromQL parser
        const value = this.getMetricValueForRule(rule);
        if (rule.condition.includes('>')) {
            return value > rule.threshold;
        }
        else if (rule.condition.includes('<')) {
            return value < rule.threshold;
        }
        return false;
    }
    getMetricValueForRule(rule) {
        // Extract metric name from condition and get its value
        if (rule.condition.includes('system_memory_usage_bytes / system_memory_total_bytes')) {
            const memUsage = this.getMetricValue('system_memory_usage_bytes');
            const memTotal = this.getMetricValue('system_memory_total_bytes');
            return memTotal > 0 ? memUsage / memTotal : 0;
        }
        // Extract simple metric names
        const metricMatch = rule.condition.match(/([a-z_]+)/);
        if (metricMatch) {
            return this.getMetricValue(metricMatch[1]);
        }
        return 0;
    }
    getMetricValue(name) {
        for (const [key, metric] of this.metrics) {
            if (key.startsWith(name)) {
                return metric.value;
            }
        }
        return 0;
    }
    // ==================== HTTP SERVER ====================
    async start() {
        if (this.isRunning) {
            throw new Error('Metrics exporter is already running');
        }
        this.server = http.createServer(this.handleRequest.bind(this));
        return new Promise((resolve, reject) => {
            this.server.listen(this.port, (error) => {
                if (error) {
                    reject(error);
                }
                else {
                    this.isRunning = true;
                    // Start metric collection
                    this.collectInterval = setInterval(() => {
                        this.collectSystemMetrics();
                        this.processAlerts();
                    }, 15000); // Every 15 seconds
                    console.log(`[PROMETHEUS EXPORTER] Metrics server started on port ${this.port}`);
                    console.log(`[PROMETHEUS EXPORTER] Metrics endpoint: http://localhost:${this.port}/metrics`);
                    this.emit('started');
                    resolve();
                }
            });
        });
    }
    async stop() {
        if (!this.isRunning)
            return;
        if (this.collectInterval) {
            clearInterval(this.collectInterval);
            this.collectInterval = null;
        }
        if (this.server) {
            return new Promise((resolve) => {
                this.server.close(() => {
                    this.isRunning = false;
                    console.log('[PROMETHEUS EXPORTER] Metrics server stopped');
                    this.emit('stopped');
                    resolve();
                });
            });
        }
    }
    handleRequest(req, res) {
        const parsedUrl = url.parse(req.url || '', true);
        if (parsedUrl.pathname === '/metrics') {
            res.writeHead(200, {
                'Content-Type': 'text/plain; version=0.0.4; charset=utf-8'
            });
            res.end(this.formatPrometheusMetrics());
        }
        else if (parsedUrl.pathname === '/health') {
            res.writeHead(200, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({
                status: 'healthy',
                uptime: (Date.now() - this.startTime) / 1000,
                metrics_count: this.metrics.size,
                active_alerts: this.activeAlerts.size
            }));
        }
        else {
            res.writeHead(404, { 'Content-Type': 'text/plain' });
            res.end('Not Found');
        }
    }
    formatPrometheusMetrics() {
        const lines = [];
        const processedMetrics = new Set();
        for (const [_, metric] of this.metrics) {
            if (!processedMetrics.has(metric.name)) {
                // Add HELP and TYPE once per metric
                lines.push(`# HELP ${metric.name} ${metric.help}`);
                lines.push(`# TYPE ${metric.name} ${metric.type}`);
                processedMetrics.add(metric.name);
            }
            // Add metric line
            const labelStr = Object.entries(metric.labels || {})
                .map(([k, v]) => `${k}="${v}"`)
                .join(',');
            const metricLine = labelStr
                ? `${metric.name}{${labelStr}} ${metric.value}`
                : `${metric.name} ${metric.value}`;
            lines.push(metricLine);
        }
        return lines.join('\n') + '\n';
    }
    // ==================== GETTERS ====================
    getMetrics() {
        return new Map(this.metrics);
    }
    getActiveAlerts() {
        return new Map(this.activeAlerts);
    }
    getAlertRules() {
        return [...this.alertRules];
    }
    isHealthy() {
        return this.isRunning && this.activeAlerts.size === 0;
    }
    getSystemStats() {
        return {
            uptime: (Date.now() - this.startTime) / 1000,
            metricsCount: this.metrics.size,
            activeAlerts: this.activeAlerts.size,
            alertRules: this.alertRules.length
        };
    }
}
exports.PrometheusMetricsExporter = PrometheusMetricsExporter;
// Default configuration
exports.DefaultPrometheusConfig = {
    port: 9090,
    collectInterval: 15000, // 15 seconds
    alertEvaluationInterval: 30000 // 30 seconds
};
