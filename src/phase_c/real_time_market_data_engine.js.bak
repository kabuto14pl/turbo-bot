"use strict";
/**
 * Phase C.1: Real-Time Market Data Integration Engine
 * Advanced WebSocket-based market data system with enterprise caching
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RealTimeMarketDataEngine = void 0;
const events_1 = require("events");
const ws_1 = __importDefault(require("ws"));
const trading_cache_manager_1 = require("../trading-bot/core/cache/trading_cache_manager");
class RealTimeMarketDataEngine extends events_1.EventEmitter {
    constructor() {
        super();
        this.connections = new Map();
        this.reconnectAttempts = new Map();
        this.lastDataTimestamp = new Map();
        this.isActive = false;
        this.exchanges = [
            {
                name: 'binance',
                wsUrl: 'wss://stream.binance.com:9443/ws',
                apiUrl: 'https://api.binance.com/api/v3',
                symbols: ['BTCUSDT', 'ETHUSDT', 'SOLUSDT'],
                reconnectInterval: 5000,
                maxReconnectAttempts: 10,
                rateLimit: 1200 // requests per minute
            },
            {
                name: 'okx',
                wsUrl: 'wss://ws.okx.com:8443/ws/v5/public',
                apiUrl: 'https://www.okx.com/api/v5',
                symbols: ['BTC-USDT', 'ETH-USDT', 'SOL-USDT'],
                reconnectInterval: 5000,
                maxReconnectAttempts: 10,
                rateLimit: 600
            }
        ];
        this.dataCache = new trading_cache_manager_1.TradingCacheManager();
        this.dataQuality = {
            uptime: 0,
            latency: 0,
            errorRate: 0,
            completeness: 0,
            cacheHitRate: 0
        };
        // Start quality monitoring
        this.startQualityMonitoring();
    }
    /**
     * Initialize real-time data streams
     */
    async initialize() {
        console.log('üöÄ Initializing Real-Time Market Data Engine...');
        try {
            // Initialize cache system
            await this.dataCache.initialize();
            // Connect to all exchanges
            for (const exchange of this.exchanges) {
                await this.connectToExchange(exchange);
            }
            this.isActive = true;
            console.log('‚úÖ Real-Time Market Data Engine initialized successfully');
            this.emit('initialized');
        }
        catch (error) {
            console.error('‚ùå Failed to initialize Real-Time Market Data Engine:', error);
            throw error;
        }
    }
    /**
     * Connect to a specific exchange
     */
    async connectToExchange(config) {
        console.log(`üîå Connecting to ${config.name}...`);
        try {
            const ws = new ws_1.default(config.wsUrl);
            ws.on('open', () => {
                console.log(`‚úÖ Connected to ${config.name}`);
                this.subscribeToSymbols(ws, config);
                this.connections.set(config.name, ws);
                this.reconnectAttempts.set(config.name, 0);
            });
            ws.on('message', (data) => {
                this.handleMarketData(data, config.name);
            });
            ws.on('error', (error) => {
                console.error(`‚ùå ${config.name} WebSocket error:`, error);
                this.handleConnectionError(config);
            });
            ws.on('close', () => {
                console.warn(`üîå ${config.name} connection closed`);
                this.handleConnectionClose(config);
            });
        }
        catch (error) {
            console.error(`‚ùå Failed to connect to ${config.name}:`, error);
            this.handleConnectionError(config);
        }
    }
    /**
     * Subscribe to market data streams
     */
    subscribeToSymbols(ws, config) {
        if (config.name === 'binance') {
            // Binance subscription format
            const streams = config.symbols.map(symbol => `${symbol.toLowerCase()}@ticker`).join('/');
            const subscriptionMessage = {
                method: 'SUBSCRIBE',
                params: config.symbols.map(symbol => `${symbol.toLowerCase()}@ticker`),
                id: Date.now()
            };
            ws.send(JSON.stringify(subscriptionMessage));
        }
        else if (config.name === 'okx') {
            // OKX subscription format
            const subscriptionMessage = {
                op: 'subscribe',
                args: config.symbols.map(symbol => ({
                    channel: 'tickers',
                    instId: symbol
                }))
            };
            ws.send(JSON.stringify(subscriptionMessage));
        }
        console.log(`üì° Subscribed to ${config.symbols.length} symbols on ${config.name}`);
    }
    /**
     * Handle incoming market data
     */
    async handleMarketData(data, exchange) {
        try {
            const parsedData = JSON.parse(data.toString());
            // Parse based on exchange format
            let marketData = null;
            if (exchange === 'binance' && parsedData.data) {
                marketData = this.parseBinanceData(parsedData.data);
            }
            else if (exchange === 'okx' && parsedData.data) {
                marketData = this.parseOKXData(parsedData.data[0]);
            }
            if (marketData) {
                // Validate data quality
                if (this.validateDataQuality(marketData)) {
                    // Cache the data
                    await this.cacheMarketData(marketData);
                    // Update quality metrics
                    this.updateDataQuality(marketData, exchange);
                    // Emit to subscribers
                    this.emit('marketData', marketData);
                }
            }
        }
        catch (error) {
            console.error(`‚ùå Error parsing market data from ${exchange}:`, error);
            this.dataQuality.errorRate += 0.01;
        }
    }
    /**
     * Parse Binance market data
     */
    parseBinanceData(data) {
        return {
            symbol: data.s,
            timestamp: parseInt(data.E),
            price: parseFloat(data.c),
            volume: parseFloat(data.v),
            bid: parseFloat(data.b),
            ask: parseFloat(data.a),
            spread: parseFloat(data.a) - parseFloat(data.b),
            change24h: parseFloat(data.P),
            volatility: Math.abs(parseFloat(data.P)) / 100
        };
    }
    /**
     * Parse OKX market data
     */
    parseOKXData(data) {
        return {
            symbol: data.instId.replace('-', ''),
            timestamp: parseInt(data.ts),
            price: parseFloat(data.last),
            volume: parseFloat(data.vol24h),
            bid: parseFloat(data.bidPx),
            ask: parseFloat(data.askPx),
            spread: parseFloat(data.askPx) - parseFloat(data.bidPx),
            change24h: parseFloat(data.chgUtc) * 100,
            volatility: Math.abs(parseFloat(data.chgUtc))
        };
    }
    /**
     * Validate data quality
     */
    validateDataQuality(data) {
        // Check for required fields
        if (!data.symbol || !data.timestamp || !data.price) {
            return false;
        }
        // Check for reasonable values
        if (data.price <= 0 || data.volume < 0) {
            return false;
        }
        // Check for data freshness (not older than 5 seconds)
        const age = Date.now() - data.timestamp;
        if (age > 5000) {
            return false;
        }
        return true;
    }
    /**
     * Cache market data
     */
    async cacheMarketData(data) {
        const cacheKey = `market_data_${data.symbol}`;
        await this.dataCache.cacheMarketData(data.symbol, '1m', [data], 60);
        // Also cache latest price for quick access
        const priceKey = `latest_price_${data.symbol}`;
        await this.dataCache.set(priceKey, data.price, 30);
    }
    /**
     * Update data quality metrics
     */
    updateDataQuality(data, exchange) {
        const now = Date.now();
        const lastTime = this.lastDataTimestamp.get(exchange) || now;
        // Calculate latency
        this.dataQuality.latency = now - data.timestamp;
        // Update completeness
        this.dataQuality.completeness = Math.min(100, ((now - lastTime) < 2000) ? 100 : 95);
        // Calculate cache hit rate
        this.dataQuality.cacheHitRate = this.dataCache.getMetrics().hitRate * 100;
        this.lastDataTimestamp.set(exchange, now);
    }
    /**
     * Handle connection errors
     */
    handleConnectionError(config) {
        const attempts = this.reconnectAttempts.get(config.name) || 0;
        if (attempts < config.maxReconnectAttempts) {
            console.log(`üîÑ Attempting to reconnect to ${config.name} (attempt ${attempts + 1})`);
            setTimeout(() => {
                this.reconnectAttempts.set(config.name, attempts + 1);
                this.connectToExchange(config);
            }, config.reconnectInterval);
        }
        else {
            console.error(`‚ùå Max reconnection attempts reached for ${config.name}`);
            this.emit('exchangeOffline', config.name);
        }
    }
    /**
     * Handle connection close
     */
    handleConnectionClose(config) {
        this.connections.delete(config.name);
        this.handleConnectionError(config);
    }
    /**
     * Start quality monitoring
     */
    startQualityMonitoring() {
        setInterval(() => {
            const connectedExchanges = this.connections.size;
            const totalExchanges = this.exchanges.length;
            this.dataQuality.uptime = (connectedExchanges / totalExchanges) * 100;
            // Emit quality metrics
            this.emit('qualityUpdate', this.dataQuality);
            // Log quality status
            if (this.dataQuality.uptime >= 99) {
                console.log('üìä Data Quality: EXCELLENT', this.dataQuality);
            }
            else if (this.dataQuality.uptime >= 95) {
                console.log('üìä Data Quality: GOOD', this.dataQuality);
            }
            else {
                console.warn('‚ö†Ô∏è Data Quality: DEGRADED', this.dataQuality);
            }
        }, 30000); // Every 30 seconds
    }
    /**
     * Get latest market data for symbol
     */
    async getLatestData(symbol) {
        try {
            const cachedData = await this.dataCache.getMarketData(symbol, '1m');
            return cachedData && cachedData.length > 0 ? cachedData[0] : null;
        }
        catch (error) {
            console.error(`‚ùå Error getting latest data for ${symbol}:`, error);
            return null;
        }
    }
    /**
     * Get data quality metrics
     */
    getDataQuality() {
        return { ...this.dataQuality };
    }
    /**
     * Get connection status
     */
    getConnectionStatus() {
        const status = {};
        for (const exchange of this.exchanges) {
            status[exchange.name] = this.connections.has(exchange.name);
        }
        return status;
    }
    /**
     * Shutdown the engine
     */
    async shutdown() {
        console.log('üõë Shutting down Real-Time Market Data Engine...');
        this.isActive = false;
        // Close all WebSocket connections
        for (const [exchange, ws] of this.connections) {
            console.log(`üîå Closing ${exchange} connection`);
            ws.close();
        }
        this.connections.clear();
        console.log('‚úÖ Real-Time Market Data Engine shutdown complete');
    }
}
exports.RealTimeMarketDataEngine = RealTimeMarketDataEngine;
exports.default = RealTimeMarketDataEngine;
