"use strict";
/**
 * ðŸš€ ADVANCED REAL-TIME TRADING SIGNALS SYSTEM
 *
 * Zaawansowany system sygnaÅ‚Ã³w tradingowych w czasie rzeczywistym
 * - WebSocket real-time data feeds
 * - ML-powered signal confidence scoring
 * - Multi-asset trading signals
 * - Advanced signal aggregation & filtering
 * - Performance-based signal weighting
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.AdvancedRealTimeTradingSignals = void 0;
const events_1 = require("events");
const logger_1 = require("../trading-bot/infrastructure/logging/logger");
const tf = __importStar(require("@tensorflow/tfjs-node"));
// ============================================================================
// ðŸ¤– ADVANCED REAL-TIME TRADING SIGNALS ENGINE
// ============================================================================
class AdvancedRealTimeTradingSignals extends events_1.EventEmitter {
    constructor(config = {}) {
        super();
        this.isActive = false;
        this.marketData = new Map();
        this.activeSignals = new Map();
        this.signalPerformance = new Map();
        // ML Models
        this.mlModels = {};
        // WebSocket connections
        this.wsConnections = new Map();
        // Signal generators
        this.signalGenerators = new Map();
        this.logger = new logger_1.Logger('AdvancedRealTimeTradingSignals');
        this.wsConfig = {
            endpoints: {
                binance: 'wss://stream.binance.com:9443/ws/',
                coinbase: 'wss://ws-feed.pro.coinbase.com',
                kraken: 'wss://ws.kraken.com'
            },
            symbols: ['BTCUSDT', 'ETHUSDT', 'ADAUSDT', 'SOLUSDT'],
            reconnectDelay: 5000,
            maxReconnects: 10,
            ...config
        };
        this.signalAggregator = new SignalAggregator();
        this.performanceTracker = new PerformanceTracker();
        this.initializeSignalGenerators();
    }
    // ========================================================================
    // ðŸš€ MAIN CONTROL METHODS
    // ========================================================================
    async start() {
        if (this.isActive) {
            this.logger.warn('ðŸ”„ Real-time signals already active');
            return;
        }
        try {
            this.logger.info('ðŸš€ Starting Advanced Real-Time Trading Signals...');
            // Load ML models
            await this.loadMLModels();
            // Initialize WebSocket connections
            await this.initializeWebSockets();
            // Start signal processing
            this.startSignalProcessing();
            this.isActive = true;
            this.logger.info('âœ… Real-time trading signals system activated!');
            this.emit('started');
        }
        catch (error) {
            this.logger.error('âŒ Failed to start real-time signals:', error);
            throw error;
        }
    }
    async stop() {
        if (!this.isActive)
            return;
        this.logger.info('ðŸ›‘ Stopping real-time signals...');
        // Close WebSocket connections
        for (const [exchange, ws] of this.wsConnections) {
            ws.close();
            this.logger.info(`ðŸ“¡ Closed ${exchange} WebSocket connection`);
        }
        this.isActive = false;
        this.logger.info('âœ… Real-time signals stopped');
        this.emit('stopped');
    }
    // ========================================================================
    // ðŸ¤– ML MODELS LOADING
    // ========================================================================
    async loadMLModels() {
        try {
            this.logger.info('ðŸ§  Loading ML models for signal generation...');
            // Price prediction model (LSTM)
            this.mlModels.pricePredictor = await this.createPricePredictionModel();
            this.logger.info('âœ… Price predictor model loaded');
            // Pattern detection model (CNN)
            this.mlModels.patternDetector = await this.createPatternDetectionModel();
            this.logger.info('âœ… Pattern detector model loaded');
            // Volatility prediction model
            this.mlModels.volatilityPredictor = await this.createVolatilityModel();
            this.logger.info('âœ… Volatility predictor model loaded');
            // Sentiment analysis model
            this.mlModels.sentimentAnalyzer = await this.createSentimentModel();
            this.logger.info('âœ… Sentiment analyzer model loaded');
            this.logger.info('ðŸŽ¯ All ML models loaded successfully');
        }
        catch (error) {
            this.logger.error('âŒ Failed to load ML models:', error);
            throw error;
        }
    }
    async createPricePredictionModel() {
        const model = tf.sequential({
            layers: [
                tf.layers.lstm({
                    units: 128,
                    returnSequences: true,
                    inputShape: [60, 8] // 60 timesteps, 8 features
                }),
                tf.layers.dropout({ rate: 0.2 }),
                tf.layers.lstm({
                    units: 64,
                    returnSequences: false
                }),
                tf.layers.dropout({ rate: 0.2 }),
                tf.layers.dense({ units: 32, activation: 'relu' }),
                tf.layers.dense({ units: 1, activation: 'linear' }) // Price prediction
            ]
        });
        model.compile({
            optimizer: tf.train.adam(0.001),
            loss: 'meanSquaredError',
            metrics: ['mae']
        });
        return model;
    }
    async createPatternDetectionModel() {
        const model = tf.sequential({
            layers: [
                tf.layers.conv1d({
                    filters: 64,
                    kernelSize: 3,
                    activation: 'relu',
                    inputShape: [50, 5] // 50 candles, 5 features (OHLCV)
                }),
                tf.layers.maxPooling1d({ poolSize: 2 }),
                tf.layers.conv1d({
                    filters: 32,
                    kernelSize: 3,
                    activation: 'relu'
                }),
                tf.layers.globalMaxPooling1d(),
                tf.layers.dense({ units: 50, activation: 'relu' }),
                tf.layers.dropout({ rate: 0.3 }),
                tf.layers.dense({ units: 3, activation: 'softmax' }) // BUY, SELL, HOLD
            ]
        });
        model.compile({
            optimizer: tf.train.adam(0.001),
            loss: 'categoricalCrossentropy',
            metrics: ['accuracy']
        });
        return model;
    }
    async createVolatilityModel() {
        const model = tf.sequential({
            layers: [
                tf.layers.dense({ units: 64, activation: 'relu', inputShape: [20] }),
                tf.layers.dropout({ rate: 0.2 }),
                tf.layers.dense({ units: 32, activation: 'relu' }),
                tf.layers.dense({ units: 16, activation: 'relu' }),
                tf.layers.dense({ units: 1, activation: 'sigmoid' }) // Volatility score 0-1
            ]
        });
        model.compile({
            optimizer: tf.train.adam(0.001),
            loss: 'binaryCrossentropy',
            metrics: ['accuracy']
        });
        return model;
    }
    async createSentimentModel() {
        const model = tf.sequential({
            layers: [
                tf.layers.embedding({ inputDim: 10000, outputDim: 128, inputLength: 100 }),
                tf.layers.lstm({ units: 64, dropout: 0.5, recurrentDropout: 0.5 }),
                tf.layers.dense({ units: 32, activation: 'relu' }),
                tf.layers.dropout({ rate: 0.3 }),
                tf.layers.dense({ units: 1, activation: 'sigmoid' }) // Sentiment score 0-1
            ]
        });
        model.compile({
            optimizer: tf.train.adam(0.001),
            loss: 'binaryCrossentropy',
            metrics: ['accuracy']
        });
        return model;
    }
    // ========================================================================
    // ðŸ“¡ WEBSOCKET CONNECTIONS
    // ========================================================================
    async initializeWebSockets() {
        this.logger.info('ðŸ“¡ Initializing WebSocket connections...');
        // Binance WebSocket
        await this.initializeBinanceWS();
        // Add other exchanges...
        // await this.initializeCoinbaseWS();
        // await this.initializeKrakenWS();
        this.logger.info('âœ… All WebSocket connections established');
    }
    async initializeBinanceWS() {
        const streams = this.wsConfig.symbols.map(symbol => `${symbol.toLowerCase()}@ticker`).join('/');
        const wsUrl = `${this.wsConfig.endpoints.binance}${streams}`;
        const ws = new WebSocket(wsUrl);
        ws.onopen = () => {
            this.logger.info('ðŸ”— Binance WebSocket connected');
            this.wsConnections.set('binance', ws);
        };
        ws.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                this.processBinanceData(data);
            }
            catch (error) {
                this.logger.error('Error processing Binance data:', error);
            }
        };
        ws.onerror = (error) => {
            this.logger.error('Binance WebSocket error:', error);
        };
        ws.onclose = () => {
            this.logger.warn('ðŸ“¡ Binance WebSocket disconnected');
            // Auto-reconnect logic
            setTimeout(() => this.initializeBinanceWS(), this.wsConfig.reconnectDelay);
        };
    }
    processBinanceData(data) {
        if (data.e === '24hrTicker') {
            const marketData = {
                symbol: data.s,
                timestamp: data.E,
                price: parseFloat(data.c),
                volume: parseFloat(data.v),
                bid: parseFloat(data.b),
                ask: parseFloat(data.a),
                spread: parseFloat(data.a) - parseFloat(data.b),
                change24h: parseFloat(data.P),
                volatility: this.calculateVolatility(data)
            };
            this.updateMarketData(marketData);
        }
    }
    calculateVolatility(tickerData) {
        const high = parseFloat(tickerData.h);
        const low = parseFloat(tickerData.l);
        const close = parseFloat(tickerData.c);
        return ((high - low) / close) * 100;
    }
    updateMarketData(data) {
        if (!this.marketData.has(data.symbol)) {
            this.marketData.set(data.symbol, []);
        }
        const symbolData = this.marketData.get(data.symbol);
        symbolData.push(data);
        // Keep only last 1000 data points
        if (symbolData.length > 1000) {
            symbolData.shift();
        }
        // Generate signals for this data point
        this.generateSignalsForSymbol(data.symbol, data);
    }
    // ========================================================================
    // ðŸŽ¯ SIGNAL GENERATION
    // ========================================================================
    initializeSignalGenerators() {
        this.signalGenerators.set('ml_price_prediction', this.generateMLPriceSignal.bind(this));
        this.signalGenerators.set('pattern_detection', this.generatePatternSignal.bind(this));
        this.signalGenerators.set('volatility_breakout', this.generateVolatilitySignal.bind(this));
        this.signalGenerators.set('momentum_signal', this.generateMomentumSignal.bind(this));
        this.signalGenerators.set('mean_reversion', this.generateMeanReversionSignal.bind(this));
    }
    async generateSignalsForSymbol(symbol, data) {
        const symbolData = this.marketData.get(symbol);
        if (!symbolData || symbolData.length < 50)
            return;
        const signals = [];
        // Generate signals from all generators
        for (const [generatorName, generator] of this.signalGenerators) {
            try {
                const signal = await generator(symbol, symbolData);
                if (signal) {
                    signals.push(signal);
                }
            }
            catch (error) {
                this.logger.error(`Error in ${generatorName}:`, error);
            }
        }
        // Aggregate and filter signals
        const aggregatedSignal = await this.signalAggregator.aggregate(signals, symbol);
        if (aggregatedSignal && aggregatedSignal.confidence > 0.7) {
            this.activeSignals.set(aggregatedSignal.id, aggregatedSignal);
            this.emit('signal', aggregatedSignal);
            this.logger.info(`ðŸŽ¯ New signal: ${symbol} ${aggregatedSignal.direction} (Confidence: ${aggregatedSignal.confidence.toFixed(3)})`);
        }
    }
    async generateMLPriceSignal(symbol, data) {
        if (!this.mlModels.pricePredictor || data.length < 60)
            return null;
        try {
            // Prepare data for prediction
            const features = this.prepareMLFeatures(data.slice(-60));
            const input = tf.tensor3d([features], [1, 60, 8]);
            // Make prediction
            const prediction = this.mlModels.pricePredictor.predict(input);
            const predictedPrice = await prediction.data();
            const currentPrice = data[data.length - 1].price;
            const priceChange = (predictedPrice[0] - currentPrice) / currentPrice;
            // Generate signal based on prediction
            let direction = 'HOLD';
            let strength = 0;
            let confidence = 0;
            if (Math.abs(priceChange) > 0.005) { // 0.5% threshold
                direction = priceChange > 0 ? 'BUY' : 'SELL';
                strength = Math.min(Math.abs(priceChange) * 10, 1);
                confidence = Math.min(strength * 1.2, 1);
            }
            // Clean up tensors
            input.dispose();
            prediction.dispose();
            if (direction === 'HOLD')
                return null;
            return {
                id: `ml_price_${symbol}_${Date.now()}`,
                symbol,
                timestamp: Date.now(),
                direction,
                strength,
                confidence,
                timeframe: '1m',
                source: 'ml_price_prediction',
                metadata: {
                    indicators: {
                        predicted_price: predictedPrice[0],
                        price_change: priceChange,
                        current_price: currentPrice
                    },
                    patterns: ['ml_price_prediction'],
                    riskLevel: strength > 0.7 ? 'HIGH' : strength > 0.4 ? 'MEDIUM' : 'LOW',
                    expectedReturn: Math.abs(priceChange),
                    stopLoss: currentPrice * (1 - (direction === 'BUY' ? 0.02 : -0.02)),
                    takeProfit: currentPrice * (1 + (direction === 'BUY' ? 0.03 : -0.03))
                }
            };
        }
        catch (error) {
            this.logger.error('Error in ML price prediction:', error);
            return null;
        }
    }
    async generatePatternSignal(symbol, data) {
        if (!this.mlModels.patternDetector || data.length < 50)
            return null;
        try {
            // Prepare candlestick data
            const candleData = this.prepareCandleFeatures(data.slice(-50));
            const input = tf.tensor3d([candleData], [1, 50, 5]);
            // Pattern detection
            const prediction = this.mlModels.patternDetector.predict(input);
            const probabilities = await prediction.data();
            // Find strongest signal
            const maxProb = Math.max(...probabilities);
            const maxIndex = Array.from(probabilities).indexOf(maxProb);
            // Clean up
            input.dispose();
            prediction.dispose();
            if (maxProb < 0.6)
                return null; // Low confidence
            const directions = ['BUY', 'SELL', 'HOLD'];
            const direction = directions[maxIndex];
            if (direction === 'HOLD')
                return null;
            return {
                id: `pattern_${symbol}_${Date.now()}`,
                symbol,
                timestamp: Date.now(),
                direction,
                strength: maxProb,
                confidence: maxProb,
                timeframe: '5m',
                source: 'pattern_detection',
                metadata: {
                    indicators: {
                        pattern_confidence: maxProb,
                        buy_prob: probabilities[0],
                        sell_prob: probabilities[1],
                        hold_prob: probabilities[2]
                    },
                    patterns: ['cnn_pattern_detection'],
                    riskLevel: maxProb > 0.8 ? 'HIGH' : 'MEDIUM',
                    expectedReturn: maxProb * 0.02,
                    stopLoss: data[data.length - 1].price * (1 - (direction === 'BUY' ? 0.015 : -0.015)),
                    takeProfit: data[data.length - 1].price * (1 + (direction === 'BUY' ? 0.025 : -0.025))
                }
            };
        }
        catch (error) {
            this.logger.error('Error in pattern detection:', error);
            return null;
        }
    }
    async generateVolatilitySignal(symbol, data) {
        if (data.length < 20)
            return null;
        const recentData = data.slice(-20);
        const avgVolatility = recentData.reduce((sum, d) => sum + d.volatility, 0) / recentData.length;
        const currentVolatility = data[data.length - 1].volatility;
        // Volatility breakout detection
        if (currentVolatility > avgVolatility * 1.5) {
            const priceChange = (data[data.length - 1].price - data[data.length - 2].price) / data[data.length - 2].price;
            return {
                id: `volatility_${symbol}_${Date.now()}`,
                symbol,
                timestamp: Date.now(),
                direction: priceChange > 0 ? 'BUY' : 'SELL',
                strength: Math.min(currentVolatility / avgVolatility / 2, 1),
                confidence: 0.6 + Math.min(currentVolatility / avgVolatility / 5, 0.3),
                timeframe: '1m',
                source: 'volatility_breakout',
                metadata: {
                    indicators: {
                        current_volatility: currentVolatility,
                        avg_volatility: avgVolatility,
                        volatility_ratio: currentVolatility / avgVolatility,
                        price_change: priceChange
                    },
                    patterns: ['volatility_breakout'],
                    riskLevel: 'HIGH',
                    expectedReturn: Math.abs(priceChange) * 1.5,
                    stopLoss: data[data.length - 1].price * (1 - (priceChange > 0 ? 0.01 : -0.01)),
                    takeProfit: data[data.length - 1].price * (1 + (priceChange > 0 ? 0.02 : -0.02))
                }
            };
        }
        return null;
    }
    async generateMomentumSignal(symbol, data) {
        if (data.length < 14)
            return null;
        // Simple momentum calculation
        const recentData = data.slice(-14);
        const rsi = this.calculateRSI(recentData.map(d => d.price));
        const macd = this.calculateMACD(data.slice(-26).map(d => d.price));
        let direction = 'HOLD';
        let strength = 0;
        if (rsi < 30 && macd.signal > 0) {
            direction = 'BUY';
            strength = (30 - rsi) / 30;
        }
        else if (rsi > 70 && macd.signal < 0) {
            direction = 'SELL';
            strength = (rsi - 70) / 30;
        }
        if (direction === 'HOLD')
            return null;
        return {
            id: `momentum_${symbol}_${Date.now()}`,
            symbol,
            timestamp: Date.now(),
            direction,
            strength,
            confidence: 0.5 + strength * 0.3,
            timeframe: '15m',
            source: 'momentum_signal',
            metadata: {
                indicators: {
                    rsi,
                    macd: macd.macd,
                    macd_signal: macd.signal,
                    macd_histogram: macd.histogram
                },
                patterns: ['rsi_oversold', 'rsi_overbought', 'macd_bullish', 'macd_bearish'],
                riskLevel: 'MEDIUM',
                expectedReturn: strength * 0.015,
                stopLoss: data[data.length - 1].price * (1 - (direction === 'BUY' ? 0.02 : -0.02)),
                takeProfit: data[data.length - 1].price * (1 + (direction === 'BUY' ? 0.03 : -0.03))
            }
        };
    }
    async generateMeanReversionSignal(symbol, data) {
        if (data.length < 20)
            return null;
        const prices = data.slice(-20).map(d => d.price);
        const sma20 = prices.reduce((sum, price) => sum + price, 0) / prices.length;
        const currentPrice = data[data.length - 1].price;
        const deviation = (currentPrice - sma20) / sma20;
        // Mean reversion opportunity
        if (Math.abs(deviation) > 0.02) { // 2% deviation
            return {
                id: `mean_reversion_${symbol}_${Date.now()}`,
                symbol,
                timestamp: Date.now(),
                direction: deviation > 0 ? 'SELL' : 'BUY', // Revert to mean
                strength: Math.min(Math.abs(deviation) * 10, 1),
                confidence: 0.4 + Math.min(Math.abs(deviation) * 5, 0.4),
                timeframe: '30m',
                source: 'mean_reversion',
                metadata: {
                    indicators: {
                        sma20,
                        current_price: currentPrice,
                        deviation,
                        deviation_pct: deviation * 100
                    },
                    patterns: ['mean_reversion'],
                    riskLevel: 'LOW',
                    expectedReturn: Math.abs(deviation) * 0.5,
                    stopLoss: currentPrice * (1 - (deviation < 0 ? 0.01 : -0.01)),
                    takeProfit: sma20
                }
            };
        }
        return null;
    }
    // ========================================================================
    // ðŸ”§ UTILITY METHODS
    // ========================================================================
    prepareMLFeatures(data) {
        return data.map(point => [
            point.price,
            point.volume,
            point.bid,
            point.ask,
            point.spread,
            point.change24h,
            point.volatility,
            Date.now() - point.timestamp // Time since data point
        ]);
    }
    prepareCandleFeatures(data) {
        return data.map((point, index) => {
            const prev = index > 0 ? data[index - 1] : point;
            return [
                prev.price, // Open (previous close)
                Math.max(point.price, prev.price), // High
                Math.min(point.price, prev.price), // Low
                point.price, // Close
                point.volume
            ];
        });
    }
    calculateRSI(prices, period = 14) {
        if (prices.length < period + 1)
            return 50;
        let gains = 0;
        let losses = 0;
        for (let i = 1; i <= period; i++) {
            const change = prices[i] - prices[i - 1];
            if (change > 0)
                gains += change;
            else
                losses -= change;
        }
        const avgGain = gains / period;
        const avgLoss = losses / period;
        if (avgLoss === 0)
            return 100;
        const rs = avgGain / avgLoss;
        return 100 - (100 / (1 + rs));
    }
    calculateMACD(prices) {
        if (prices.length < 26)
            return { macd: 0, signal: 0, histogram: 0 };
        const ema12 = this.calculateEMA(prices, 12);
        const ema26 = this.calculateEMA(prices, 26);
        const macd = ema12 - ema26;
        // Simple signal line (9-period EMA of MACD)
        const signal = macd * 0.2; // Simplified
        const histogram = macd - signal;
        return { macd, signal, histogram };
    }
    calculateEMA(prices, period) {
        if (prices.length === 0)
            return 0;
        const multiplier = 2 / (period + 1);
        let ema = prices[0];
        for (let i = 1; i < prices.length; i++) {
            ema = (prices[i] * multiplier) + (ema * (1 - multiplier));
        }
        return ema;
    }
    startSignalProcessing() {
        // Process signals every second
        setInterval(() => {
            this.processActiveSignals();
        }, 1000);
    }
    processActiveSignals() {
        const now = Date.now();
        const expiredSignals = [];
        for (const [signalId, signal] of this.activeSignals) {
            // Remove signals older than 5 minutes
            if (now - signal.timestamp > 300000) {
                expiredSignals.push(signalId);
            }
        }
        expiredSignals.forEach(id => {
            this.activeSignals.delete(id);
        });
    }
    // ========================================================================
    // ðŸ“Š PUBLIC METHODS
    // ========================================================================
    getActiveSignals() {
        return Array.from(this.activeSignals.values());
    }
    getSignalsForSymbol(symbol) {
        return Array.from(this.activeSignals.values()).filter(signal => signal.symbol === symbol);
    }
    getPerformanceMetrics() {
        return this.signalPerformance;
    }
    isSystemActive() {
        return this.isActive;
    }
}
exports.AdvancedRealTimeTradingSignals = AdvancedRealTimeTradingSignals;
// ============================================================================
// ðŸŽ¯ SIGNAL AGGREGATOR
// ============================================================================
class SignalAggregator {
    async aggregate(signals, symbol) {
        if (signals.length === 0)
            return null;
        // Group signals by direction
        const buySignals = signals.filter(s => s.direction === 'BUY');
        const sellSignals = signals.filter(s => s.direction === 'SELL');
        // Determine dominant direction
        let dominantDirection;
        let relevantSignals;
        if (buySignals.length > sellSignals.length) {
            dominantDirection = 'BUY';
            relevantSignals = buySignals;
        }
        else if (sellSignals.length > buySignals.length) {
            dominantDirection = 'SELL';
            relevantSignals = sellSignals;
        }
        else {
            // Equal signals, choose based on confidence
            const buyConfidence = buySignals.reduce((sum, s) => sum + s.confidence, 0);
            const sellConfidence = sellSignals.reduce((sum, s) => sum + s.confidence, 0);
            if (buyConfidence > sellConfidence) {
                dominantDirection = 'BUY';
                relevantSignals = buySignals;
            }
            else {
                dominantDirection = 'SELL';
                relevantSignals = sellSignals;
            }
        }
        // Calculate aggregated metrics
        const avgStrength = relevantSignals.reduce((sum, s) => sum + s.strength, 0) / relevantSignals.length;
        const avgConfidence = relevantSignals.reduce((sum, s) => sum + s.confidence, 0) / relevantSignals.length;
        // Apply ensemble boost
        const ensembleBoost = Math.min(relevantSignals.length * 0.1, 0.3);
        const finalConfidence = Math.min(avgConfidence + ensembleBoost, 1);
        return {
            id: `aggregated_${symbol}_${Date.now()}`,
            symbol,
            timestamp: Date.now(),
            direction: dominantDirection,
            strength: avgStrength,
            confidence: finalConfidence,
            timeframe: 'aggregated',
            source: 'signal_aggregator',
            metadata: {
                indicators: {
                    signal_count: relevantSignals.length,
                    ensemble_boost: ensembleBoost,
                    source_list: relevantSignals.map(s => s.source).join(',')
                },
                patterns: ['ensemble_aggregation'],
                riskLevel: finalConfidence > 0.8 ? 'HIGH' : finalConfidence > 0.6 ? 'MEDIUM' : 'LOW',
                expectedReturn: avgStrength * 0.02,
                stopLoss: 0,
                takeProfit: 0
            }
        };
    }
}
// ============================================================================
// ðŸ“ˆ PERFORMANCE TRACKER
// ============================================================================
class PerformanceTracker {
    constructor() {
        this.signalHistory = new Map();
        this.performanceData = new Map();
    }
    trackSignal(signal) {
        const source = signal.source;
        if (!this.signalHistory.has(source)) {
            this.signalHistory.set(source, []);
        }
        this.signalHistory.get(source).push(signal);
        this.updatePerformanceMetrics(source);
    }
    updatePerformanceMetrics(source) {
        const signals = this.signalHistory.get(source) || [];
        if (signals.length === 0)
            return;
        // Mock performance calculation (in real system, would track actual trades)
        const accuracy = 0.6 + Math.random() * 0.3; // 60-90%
        const profitability = 0.5 + Math.random() * 0.4; // 50-90%
        const winRate = accuracy;
        const avgReturn = 0.01 + Math.random() * 0.02; // 1-3%
        const performance = {
            signalId: source,
            source,
            accuracy,
            profitability,
            sharpeRatio: profitability / 0.15, // Mock Sharpe
            maxDrawdown: 0.05 + Math.random() * 0.1, // 5-15%
            totalTrades: signals.length,
            winRate,
            avgReturn,
            reliability: (accuracy + profitability + winRate) / 3
        };
        this.performanceData.set(source, performance);
    }
    getPerformance(source) {
        return this.performanceData.get(source);
    }
    getAllPerformance() {
        return this.performanceData;
    }
}
// ============================================================================
// ðŸš€ EXPORT
// ============================================================================
// Example usage:
if (require.main === module) {
    const signalSystem = new AdvancedRealTimeTradingSignals({
        symbols: ['BTCUSDT', 'ETHUSDT', 'ADAUSDT'],
        reconnectDelay: 3000
    });
    signalSystem.on('signal', (signal) => {
        console.log(`ðŸŽ¯ New Signal: ${signal.symbol} ${signal.direction} (${(signal.confidence * 100).toFixed(1)}%)`);
    });
    signalSystem.start();
}
